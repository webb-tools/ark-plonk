<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ARK-PLONK Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1: Background Material</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Chapter 2: PLONK</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Chapter 3: ARK-PLONK library</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ARK-PLONK Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-1-background-material"><a class="header" href="#chapter-1-background-material">Chapter 1: Background Material</a></h1>
<h2 id="groups"><a class="header" href="#groups">Groups</a></h2>
<p>A binary operation $<em>$ on a set $G$ is a mapping from $G\times G$ to $G$, which associates to elements $x$ and $y$ of $G$ a third element $x</em>y$ of $G$. </p>
<h4 id="definition"><a class="header" href="#definition">Definition:</a></h4>
<p>A group $(G, <em>)$ consists of a set $G$ together with a binary operation $</em>$ for which the following properties are satisfied: </p>
<ul>
<li>Associativity: $(x<em>y)<em>z=x</em>(y</em>z),; \forall x,y,z\in G $ </li>
<li>Neutral element: $\exists! ; e \in G,; e<em>x=x=x</em>e,; \forall x\in G$</li>
<li>Inverse element: $\forall x\in G, ; \exists! ; x'\in G,; x*x'=e=x'*x$ where $e$ is the neutral element of $G$. </li>
</ul>
<p>A group $G$ is Abelian (or commutative) if: $x<em>y=y</em>x,\forall x,y\in G$</p>
<h3 id="cyclic-groups"><a class="header" href="#cyclic-groups">Cyclic groups:</a></h3>
<h4 id="definition-1"><a class="header" href="#definition-1">Definition:</a></h4>
<p>A group $G$ is said to be cyclic, with generator $x$, if every element of $G$ is of
the form $x^n$ for some integer $n$.</p>
<h2 id="fields"><a class="header" href="#fields">Fields</a></h2>
<p>A field $F$ is a set with two binary operations $+$ and $*$ that satisfies the following field axioms:</p>
<ul>
<li>Closure under addition:  $\forall x,y\in F,; x+y\in F$</li>
<li>Closure under multiplication:  $\forall x,y\in F,; x*y\in F$</li>
<li>Additive inverses:  $\forall x\in F,  y\in F$ such that  $x+y=0$</li>
<li>Multiplication inverses:  $\forall x\in F$ such that $x\neq 0, ; \exists ; y\in F$ such that $x*y=1$, 
$y$ is called the multiplicative inverse of $x$ and is denoted $x^{-1}$ or $\dfrac{1}{x}$</li>
<li>The distributive law:  $\forall x,y,z\in F,; x*(y+z)=x<em>y+x</em>z$</li>
</ul>
<h3 id="finite-fields"><a class="header" href="#finite-fields">Finite Fields:</a></h3>
<p>A finite field is a field $F_q$ with a finite number of elements. The order of a finite field $$|F_q|=q=p^k$$ 
for some integer $k\geq 1$ and $p$ prime equals the number of elements in the field.</p>
<h2 id="elliptic-curves"><a class="header" href="#elliptic-curves">Elliptic curves</a></h2>
<p>For ARK-PLONK, we use pairing friendly elliptic curves defined over very large finite fields $|F_p|≈2^{256}$. In the following we will explain what is an elliptic curve, pairings and elliptic curves over finite fields.</p>
<h3 id="definition-2"><a class="header" href="#definition-2">Definition</a></h3>
<p>An Elliptic curve $E$ is a mathematical object defined over a field $F$ and generally expressed in the following Weierstrass form:
$$y^2=x^3+ax+b$$ 
for some $a,b\in F_q$ where $(x,y)$ are called &quot;affine coordinates&quot; </p>
<h3 id="elliptic-curves-over-finite-fields"><a class="header" href="#elliptic-curves-over-finite-fields">Elliptic curves over finite fields</a></h3>
<p>We will mainly focus on elliptic curves over finite fields since they are the ones used for cryptographic applications. An elliptic curve over a finite field $F_q$ is an abelian group $G$ with a finite number of points $n$ such that $n=|G|$ (order of the group $G$). </p>
<p>The group on which the elliptic curve is defined is the one used for many cryptographic protocols. An elliptic curve over a finite field is represented in the projective plane, such a curve will have an additional point at infinity $O$ which serves as the identity of the group. There are several ways to define the curve equation, but for the purpose of doing the group law arithmetics, let $y^2=x^3+b$ for some constant $b\in F_q$.</p>
<h3 id="group-law"><a class="header" href="#group-law">Group law</a></h3>
<p>We can define an abelian group $G$ over elliptic curves as follows:</p>
<ul>
<li>The elements of the group are the points of an elliptic curve</li>
<li>The identity element is the point $O$ defined as $(0,1,0)$</li>
<li>The inverse of a point $P=(x,y,z)$  is the point $-P=(x,-y,z)$</li>
<li>Commutativity:  $P+Q=Q+P$</li>
<li>Associativity: $P+(Q+R)=(P+Q)+R$</li>
</ul>
<figure>
<img src="images/images/EC.png"
     alt="EC arithmetic"
     style="float: left; margin-right: 10px;" />
<figcaption>Figure 1: Elliptic curve arithmetics</figcaption>
</figure>
<p>We can identify four cases in the group law: point addition $P+Q=-R$
which basically draws the line that intersects both points and finds a third point $R$, the addition is simply $-R$ (negate the y-coordinate). The second case $P+Q+Q=O$ is basically when the addition of both points $P$ and $Q$ doesn’t result in a third point $R$ cause in this case the line passing through $P$ and $Q$ is tangent to the curve.  Let us assume that $Q$ is the tangency point, then $P+Q=-Q$. The third case $P+Q=O$ is when a point $P$ is being added to its negation $Q=-P$, their addition equals point at infinity $O$. The final case $P+P=O$ is when a point is being added to itself (called point doubling).</p>
<h4 id="point-addition"><a class="header" href="#point-addition">Point addition</a></h4>
<p>We will first compute $P+Q$ in the affine form and then projective form. </p>
<ol>
<li>We have two points $P=(x_p,y_p)$ and $Q=(x_q,y_q)$ where $P\neq Q$. If $P=O$ then $P$ is the identity point which means $P+Q=Q$. Likewise if $Q=O$, then $P+Q=P$ <br />
Else, $P+Q=S$ for $S=(x_s,y_s)$ where $S=-R$ (the point represented in the graph) such that: $$x_s=\lambda^2-x_p-x_q$$ and $$y_s=\lambda(x_p-x_s)-y_p$$   where      $\lambda=\dfrac{y_q-y_p}{x_q-x_p}$</li>
<li>In the projective form, each elliptic curve point has 3 coordinates instead of 2 $(x,y,z)$ for $z\neq 0$ (for all points except the point at infinity). Using the projective form allows us to give coordinates to the point at infinity. It also speeds up some of the most used arithmetic operations in the curve. The forward mapping is given by $(x,y)\rightarrow (xz,yz,z)$ and reverse mapping is giving by $(x,y,z)(\dfrac{x}{z},\dfrac{y}{z})$. Let $P=(x_p,y_p,z_p)$ and $Q=(x_q,y_q,z_q)$ and $\dfrac{x_p}{z_q}\neq\dfrac{x_q}{z_p}$. </li>
</ol>
<figure>
<img src="images/images/ECP.png"
     alt="projective"
     style="float: left; margin-right: 10px;" />
<figcaption>Figure 2: Graphical representation of the map with z =1</figcaption>
</figure>
<p>By expanding the previous arithmetics, we have:</p>
<p>$\lambda=\dfrac{\dfrac{y_q}{z_q}-\dfrac{y_p}{z_p}}{\dfrac{x_q}{z_q}-\dfrac{x_p}{z_p}}=\dfrac{\dfrac{y_q}{z_q}-\dfrac{y_p}{z_p}}{\dfrac{x_q}{z_q}-\dfrac{x_p}{z_p}}*\dfrac{z_pz_q}{z_pz_q}$ </p>
<p>$\lambda=\dfrac{y_qz_p-y_pz_q}{x_qz_p-x_pz_q}$ </p>
<p>$x_s=\lambda^2-\dfrac{x_p}{z_p}-\dfrac{x_q}{z_q}$ and     $y_s=\lambda(\dfrac{x_p}{z_p}-x_s)-\dfrac{y_p}{z_p}$</p>
<h4 id="point-doubling"><a class="header" href="#point-doubling">Point doubling</a></h4>
<p>We will compute $P+P=2P$ in the affine form as follows:<br />
If $P=O$ then $2P=O$ <br />
Else  $P=(x,y)$:<br />
  If $y=0$ then $2P=O$<br />
  Else $2P=(x',y')$</p>
<p>such that: the derivative $\lambda=\dfrac{dy}{dx}=\dfrac{3x^2}{2y},; x'=\lambda^2-2x;$   and $y'=\lambda(x-x')-y=\lambda^3+3\lambda x-y$</p>
<h4 id="the-discrete-logarithm-problem"><a class="header" href="#the-discrete-logarithm-problem">The discrete logarithm problem</a></h4>
<p>The security of many cryptographic techniques depends on the intractability of the discrete logarithm problem.</p>
<h4 id="definition-3"><a class="header" href="#definition-3">Definition:</a></h4>
<p>Let $G$ be a multiplicative group. The discrete logarithm problem (DLP) is:
Given $g,h\in G$ to find $a$, if it exists, such that $h=g^a$.</p>
<h4 id="elliptic-curve-discrete-logarithm-problem--ecdlp"><a class="header" href="#elliptic-curve-discrete-logarithm-problem--ecdlp">Elliptic Curve Discrete Logarithm Problem  (ECDLP)</a></h4>
<p>Let $E$ be an elliptic curve of the Weierstrass form defined over a finite field $F_q$. Let $S$ and $T$ be two points in $E(F_q)$. Find an integer $m$ such that:
$$T=mS$$</p>
<p>The fastest method to solve the ECDLP problem in $E(F_q)$ is the <a href="https://www.ams.org/mcom/1978-32-143/S0025-5718-1978-0491431-9/S0025-5718-1978-0491431-9.pdf">Pollard Rho</a> method which has exponential complexity $O(\sqrt{|G|})$. In order for this algorithm to be exponential, we need to define elliptic curves over very large fields $|F_p|≈2^{256}$ which is currently the case for ARK-PLONK.</p>
<h3 id="pairings"><a class="header" href="#pairings">Pairings</a></h3>
<p>Pairing based-cryptography is used in many cryptographic applications like signature schemes, key agreement, zero knowledge...etc.<br />
For example, pairings are used to create efficient circuit-based zero knowledge proofs.</p>
<h4 id="definition-4"><a class="header" href="#definition-4">Definition</a></h4>
<p>A pairing $e$ is a bilinear map $〈·,·〉$  defined as: 
$$e:G_1\times G_2\rightarrow G_T$$
Such that $G_1,G_2$ and $G_T$ are abelian groups. The bilinear property means that:
$e(P+P',Q)=e(P,Q)+e(P',Q)$<br />
$e(P,Q+Q')=e(P,Q)+e(P,Q')$</p>
<p>​​From which, we deduce the following transformations:</p>
<p>$$e([a]P,[b]Q)=e(P,[b]Q)^a=e([a]P,Q)^b=e(P,Q)^{ab}=e([b]P,[a]Q)$$</p>
<p>for $P,P'\in G_1$ and $Q,Q'\in G_2$ and $a,b\in \Z$</p>
<h3 id="pairing-friendly-curves"><a class="header" href="#pairing-friendly-curves">Pairing friendly curves</a></h3>
<p>In zk-SNARK schemes such as PLONK, we need to manipulate very large polynomials in order to perform efficient multi-point evaluation/interpolation with fast fourier transforms. We therefore target a subfamily of curves that have:</p>
<ul>
<li>Optimal extension field towers.</li>
<li>Simple twisting isomorphisms.</li>
</ul>
<h4 id="montgomery-curve"><a class="header" href="#montgomery-curve">Montgomery curve</a></h4>
<p>Montgomery curves were first introduced by Peter L. as a way to accelerate elliptic curve methods of factorization  and then became central to elliptic curve cryptography. Later, these same qualities also led to many efficient implementations of elliptic curve cryptosystems, most notably Bernstein’s Curve25519 software.</p>
<h5 id="definition-5"><a class="header" href="#definition-5">Definition:</a></h5>
<p>A Montgomery curve over $F_q$ is an elliptic curve defined as
$$E_{(A,B)}: By^2=x(x^2+Ax+1)$$
where $A$ and $B$ are parameters in $F_q$ satisfying $B\neq 0$ and $A^2\neq 4$. </p>
<h4 id="edwards-curves-and-twisted-edwards-curves"><a class="header" href="#edwards-curves-and-twisted-edwards-curves">Edwards Curves and Twisted Edwards Curves</a></h4>
<p>Edwards curves are a family of elliptic curves that uses Edwards form instead of the more well known Weierstrass form used by elliptic curves. Edwards curves provide better efficiency and security than a general elliptic curve. For example the <a href="http://cr.yp.to/ecdh.html">edwards25519</a> curve is faster than <a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a> curve and considered to be more secure according to the <a href="https://safecurves.cr.yp.to/twist.html">safe curve security assessments</a>. The edwards25519 is considered to be secure against <a href="https://safecurves.cr.yp.to/twist.html">twist attacks</a> (small group and invalid group attacks) whereas the secp256k1 is considered to be vulnerable to those.</p>
<p>In ARK-PLONK, the user is free to choose which pairing friendly and embedded curve they wish to work with. Currently, we have only tested this functionality with the pairing friendly <a href="https://z.cash/blog/cultivating-sapling-new-crypto-foundations/">Bls12-381</a> and <a href="https://docs.rs/ark-bls12-377/latest/ark_bls12_377/">Bls12-377</a> which have embedded <a href="https://z.cash/technology/jubjub/">jubjub</a> and <a href="https://docs.rs/ark-ed-on-bls12-377/0.3.0/ark_ed_on_bls12_377/">this twisted edwards</a> curve but theoretically any curve that satisfies the criteria for the PLONK protocol should work fine (for example <a href="https://docs.rs/ark-bn254/latest/ark_bn254/">BN254</a> and <a href="https://iden3-docs.readthedocs.io/en/latest/iden3_repos/research/publications/zkproof-standards-workshop-2/baby-jubjub/baby-jubjub.html">babyjubjub</a> which are already implemented in arkworks and thus they should work fine).</p>
<h5 id="definitions"><a class="header" href="#definitions">Definitions:</a></h5>
<h4 id="edwards-curves"><a class="header" href="#edwards-curves">Edwards curves:</a></h4>
<p>An Edwards curve over $k$ is a curve: </p>
<p>$$E: x^2+y^2=1+dx^2y^2-x^2$$ 
where $d\in k-{0,1}$ and $k$ is a field with $char(k)\neq 2$.</p>
<h4 id="twisted-edward-curves"><a class="header" href="#twisted-edward-curves">Twisted Edward Curves:</a></h4>
<p>Fix a field $k$ with $char(k)\neq 2$ and distinct non-zero elements $a,d\in k$. The Twisted Edwards curve with coefficients $a$ and $d$ is the curve $$E_{E_{a,b}}:ax^2+y^2=1+dx^2y^2$$
An Edwards curve is a Twisted Edwards Curve with $a=1$.</p>
<h4 id="correspondence-with-montgomery-curves"><a class="header" href="#correspondence-with-montgomery-curves">Correspondence with Montgomery curves</a></h4>
<p>Every Twisted Edwards curve is birationally equivalent to an elliptic curve in Montgomery form, and vice versa. </p>
<h4 id="curve25519"><a class="header" href="#curve25519">Curve25519</a></h4>
<p>Curve25519 is a Montgomery curve providing 128 bits of security defined as:    $$y^2=x^3+ax^2+x$$
over prime field $p$ where: $b=1$.<br />
The curve is birationally equivalent to a twisted Edwards curve used in the Ed25519 signature scheme.</p>
<h4 id="barreto-naehrig-curvesbn-curves"><a class="header" href="#barreto-naehrig-curvesbn-curves">Barreto-Naehrig curves(BN curves)</a></h4>
<p>The <a href="https://eprint.iacr.org/2005/133.pdf">BN-curve</a> is a pairing friendly elliptic curve built over a field $F_q$ for $q\geq 5$ that achieves both high security and efficiency and has optimal ate pairing. BN curves with 256-bit (for example BN256) were believed to provide a 128-bit security level, but due to recent research <a href="https://link.springer.com/article/10.1007/s00145-018-9280-5">exTNFS</a> this number dropped to 100-bits of security.</p>
<h4 id="barreto-lynn-scott-curves-bls-curves"><a class="header" href="#barreto-lynn-scott-curves-bls-curves">Barreto-Lynn-Scott curves (BLS curves)</a></h4>
<p>A BLS curve is a pairing over BLS curves that constructs optimal Ate pairings. BLS12-381 is optimal for zk-SNARKs at the 128-bit security level and is implemented by the zcash team. Bls12-381 has an embedded Jubjub curve. </p>
<p>BLS-12 curves are a more efficient choice than BN curves in terms of optimal Ate pairings, and they have a better security level (Bls12-381 provides 128-bits security whereas BN256 provides only 100-bits security) </p>
<p><strong>Jubjub curve:</strong> is a twisted Edwards curve of the form $-x^2+y^2=dx^2y^2$ built over the BLS12-381 scalar field.</p>
<h2 id="lagrange-basis-and-polynomial-interpolation"><a class="header" href="#lagrange-basis-and-polynomial-interpolation">Lagrange basis and polynomial interpolation</a></h2>
<p>Polynomial interpolation is a process where a given set of points $(x_i, y_i)$, $i \in [n]$ allows us
to construct a polynomial $f(x)$ that passes through all of them. We will assume
that $x_i \neq x_j$ for all distinct $i,j$ pairs, otherwise there is a repeated pair or it is not
possible to construct the polynomial as it would have to take two different values at the same $x$-point.</p>
<p>Notice that for a set of 2 points, we can find a line that crosses both of them, for a
set of 3 points, a parabola, and in general, for a set of $n$ points there is a polynomial of degree
$n-1$ that contains all of them.</p>
<p>The Lagrange interpolation consists of 2 steps:</p>
<ol>
<li>
<p>Construct a <strong>Lagrange basis</strong>. This is a set of $n$ polynomials of degree $n-1$ that
take the value 0 at all points of the set except one, where their value is 1. Expressed in a formula:
$$
L_i(x) =
\begin{cases}
0, &amp; \text{if }\ x = {x_j}, j \in [n], j\neq i\
1, &amp; \text{if }\ x = x_i
\end{cases}
$$
The polynomials $L_i$ can be constructed in the following way:
$$
L_i(x) = \prod_{0 \leq j &lt; n\text{,  }j\neq i}
\frac{x-x_j}{x_i - x_j}
$$
Notice that this product has $n-1$ terms, and therefore results in a degree $n-1$ polynomial.</p>
</li>
<li>
<p>Scale and sum the polynomials of the basis.
$$
f(x) = \sum_{i=0}^{n-1} y_i \cdot L_i(x)
$$
The properties of the Lagrange basis now allow us to scale each polynomial to its target vale --
multiplying by $y_i$ and then add up all the terms.</p>
</li>
</ol>
<p>The important observation we can extract from the Lagrange interpolation is that given a fixed set
of points $x_1,\dots,x_n$ (an evaluation domain) we can represent any polynomial of degree $d&lt;n$
by its evaluations $f(x_i)$ at $d+1$ points in the set. As it turns out, this representation is
much more convenient than the usual coefficient representation as it provides a very simple and fast
way of computing sums and multiplication of polynomials.
However, the coefficient form is still useful for evaluating the polynomial at points outside the evaluation domain.</p>
<p>Switching between these two forms of representation is very useful. The coefficient form is
preferred when the polynomial must be evaluated at a random point (outside of the evaluation
domain). The evaluation form is better suited for operations between polynomials such as
addition, multiplication and exact quotients. The algorithm that allows us to efficiently switch
between representations is the Fast Fourier Transform (FFT).  This is an efficient algorithm for the
more general discrete Fourier Transform (DFT). It has a complexity of $\mathcal{O}(n \cdot log(n))$
with $n$ being the degree of the polynomial.</p>
<h4 id="fast-fourier-transform-algorithm"><a class="header" href="#fast-fourier-transform-algorithm">Fast Fourier Transform algorithm</a></h4>
<p>The FFT is generally defined over the complex numbers but in the crypto context it is always used over
a finite field $\mathbb{F}$.  The only requisite for $\mathbb{F}$ is that it have a large
multiplicative subgroup $H$ of order $n=2^k$ for some $k \in \mathbb{N}$.  This subgroup $H$ will be
the evaluation domain and it will consist of the $n^{th}$ roots of unity
$$
H = { \omega, \omega^2, \dots, \omega^n } =
{ x \in \mathbb{F} | x^n -1 =0 }
$$</p>
<h2 id="commitment-schemes"><a class="header" href="#commitment-schemes">Commitment schemes</a></h2>
<p>A commitment scheme $C$ is a protocol between two parties: a prover $P$ and a verifier $V$. The goal of such a scheme is to satisfy the following security properties:</p>
<ul>
<li><strong>Hiding:</strong> $P$ should be able to commit to a value $m$ by encoding it using a key $P_K$ without $V$ learning any information about $m$.</li>
<li><strong>Binding:</strong> $P$ cannot “cheat” by sending a different key $P_K'$ which opens $C$ to a different value $m'$. </li>
</ul>
<p>This is very useful in various cryptographic applications including zero-knowledge proofs. A commitment scheme can either be interactive or non-interactive depending on the use case. Their security assumption also varies between perfect or computational security with respect to the hiding and binding properties. </p>
<p>There are different combinations of these properties but the most famous ones are perfectly binding and computationally hiding commitment schemes, and computationally binding and perfectly hiding commitment schemes.<br />
In the first scheme, $P$ generates the public key and sends it to $V$. The perfectly binding means $P$ is unable to change the commitment value after it has been committed to. The computational hiding means the probability of $V$ being able to guess the commitment value is negligible.<br />
In the second scheme, $V$ generates the public key and sends it to $P$. The computational binding means the chance of being able to change the commitment is negligible. The perfectly hiding means that a commitment to a message $m$ reveals no information about $m$.
For a detailed explanation of those properties, check this <a href="https://homepages.cwi.nl/%7Eschaffne/courses/crypto/2014/papers/ComZK08.pdf">article</a>. </p>
<h4 id="definition-6"><a class="header" href="#definition-6">Definition:</a></h4>
<p>A non-interactive commitment scheme has the following three algorithms:</p>
<ol>
<li>
<p><strong>Key generation (setup)</strong> $(1^k)$: The algorithm key outputs a pair of keys $(P_K,V_K)$ that is sent to the prover and verifier respectively for a given security parameter $k$.</p>
</li>
<li>
<p><strong>Commitment</strong> $(P_K,m)$: The algorithm com takes as input the prover key $P_K$ and the message $m$ and outputs the commitment $C$ and an opening value $d$ which will be used by the verifier.</p>
</li>
<li>
<p><strong>Verification</strong> $(V_K,C,m,d)$: The algorithm takes the verification key $V_K, C, m$ and $d$ as input and outputs yes or no depending on whether the verification is successful.</p>
</li>
</ol>
<h3 id="kate-polynomial-commitment-scheme-pcs"><a class="header" href="#kate-polynomial-commitment-scheme-pcs">Kate Polynomial commitment scheme (PCS)</a></h3>
<p>Plonk uses Polynomial commitments, in particular Kate commitments (KZG10) to construct a fully-succinct zk-SNARK protocol with a constant proof size and verification time. KZG10 allows the prover to commit to a set of polynomials and to then show correct evaluation of these polynomials in a set of points with only one small proof. 
KZG is not the only PC scheme that could be used to construct ZK Proof systems but is the best one in terms of succinctness compared to other schemes like FRI, DARK and IPA where the proof size increases with the increase of the circuit scale. For example, the DARK scheme has logarithmic proof size and linear verification time. In terms of security, the FRI-based ZK-STARKs algorithm provides both plausible quantum-resistance and does not require any trusted setups. KZG however uses elliptic curve pairings, which are not quantum resistant and requires a third-party trusted setup.</p>
<p>We will first provide a formal definition of the original version of Kate commitments in which the prover commits to a polynomial $f$ and then performs an evaluation opening at a single point. We will then introduce the batched version, which is the one actually used in Plonk. </p>
<h4 id="terminology"><a class="header" href="#terminology">Terminology:</a></h4>
<p>Let $\phi\in F_p[X]$ be a polynomial of degree $\leq t$ in $F_p[X]$ where $F_p[X]$ is a polynomial ring over the finite field $F_p$ of prime order $p$. Let $G$ be an elliptic curve group of prime order $p$ such that there exists a symmetric bilinear pairing $e:G\times G\rightarrow G_T$ into the multiplicative group $G_T$ and for which the t-Strong Diffie-Hellman (t-SDH) Assumption holds. Let $g$ be a generator of  $G$. We will be using the multiplicative notation of the DLP assumption explained earlier instead of the additive notation for the EC group. We will use the following notation: $[x]=g^x​​$</p>
<h4 id="definition-7"><a class="header" href="#definition-7">Definition:</a></h4>
<p>A polynomial  commitment  scheme  consists  of  six  algorithms:<br />
<strong>Setup, Commit, Open, VerifyPoly, CreateWitness, and VerifyEval</strong>.</p>
<ol>
<li>
<p><strong>Setup:</strong> This step is run by a trusted or distributed authority and generates a commitment pair of a public and secret key $(P_K,S_K)$ as follows: $$⟨\delta,[1], [\alpha], [\alpha^2],.........,[\alpha^t]⟩$$  where $\delta=(e,G,G_t)$ is a bilinear pairing group, $⟨[1], [\alpha], [\alpha^2],.........,[\alpha^t]⟩\in G^{t+1}$ and $S_K=\alpha$  such that $\alpha \in F_p$. 
Note that $S_K$ is not required in the rest of the scheme.</p>
</li>
<li>
<p><strong>Commit:</strong> The prover computes a commitment $C$ which hides the polynomial $\phi(x)$ as follows: $$     C=[\phi(\alpha)] =\prod_{j=0}^{t}([\alpha^j])^{\phi_j}$$</p>
</li>
</ol>
<p>Where $\phi(\alpha)$ is an evaluation of the polynomial $\phi$ at point $\alpha$, $\phi(x)=\sum_{j=0}^{t}\phi_jx^j$ and $t=deg(\phi)$. </p>
<ol start="3">
<li>
<p><strong>Open:</strong> The prover outputs the polynomial $\phi(x)$ used to create the commitment.</p>
</li>
<li>
<p><strong>VerifyPoly:</strong> The verifier checks if $C$ is indeed a commitment to $\phi(x)$ as verifying if $C$ is equal to $[\phi(\alpha)]$. The verifier is able to do so since: $$[\phi(\alpha)]=\prod_{j=0}^{t}([\alpha^j])^{\phi_j}$$ and $⟨[1], [\alpha], [\alpha^2],.........,[\alpha^t]⟩$ is known to the verifier.</p>
</li>
<li>
<p><strong>CreateWitness:</strong> The prover outputs $&lt;\beta,\phi(\beta),w_{\beta}&gt;$, where $w_{\beta}$ is a witness for the evaluation $\phi(\beta)$ of $\phi(x)$ at index $\beta\neq \alpha$ chosen by the verifier. $$w_{\beta}=g^{\Psi_{\beta}(\alpha)}$$  and $$\Psi_{\beta}(x)=\dfrac{\phi(x)-\phi(\beta)}{x-\beta}(x)$$</p>
</li>
</ol>
<p>The construction of $\Psi$ is based on an algebraic property of polynomials which guarantees that $\psi(x)-\psi(\beta)$ is divisible by $x- \beta$ for any $\beta\in F_p$.</p>
<ol start="6">
<li><strong>VerifyEval:</strong> In this last step, the verifier checks if $\phi(\beta)$ is indeed the evaluation of $\phi(x)$ at index $\beta$ by checking if the following holds: $$e(C,g)=e(g^{\Psi_{\beta}(\alpha)},g^{\alpha}.g^{-\beta})e(g,g)^{\phi(\beta)}$$</li>
</ol>
<h2 id="zero-knowledge-proof-systems"><a class="header" href="#zero-knowledge-proof-systems">Zero Knowledge Proof systems</a></h2>
<p>Before we start talking about zero knowledge proof systems, let's first define what a proof system is:<br />
A proof system is a protocol by which one party (prover) wants to convince another party (verifier) that a given statement is true. </p>
<h3 id="zero-knowledge-proof-system"><a class="header" href="#zero-knowledge-proof-system">Zero knowledge proof system:</a></h3>
<p>In zero-knowledge proofs, the prover convinces the verifier about the truthfulness of the statement without revealing any information about the statement itself.</p>
<h4 id="properties"><a class="header" href="#properties">Properties</a></h4>
<p>A zero-knowledge proof needs to fulfill each of the following properties to be fully described:</p>
<ul>
<li><strong>Completeness:</strong>  An honest prover is always able to convince the verifier of the truthfulness of their claim.</li>
<li><strong>Soundness:</strong> If the prover’s claim is false (malicious prover), the verifier is not convinced.</li>
<li><strong>Zero knowledge:</strong> The proof should not reveal any information to the verifier beyond the truthfulness of the given claim.</li>
</ul>
<h4 id="types-of-zero-knowledge-proofs"><a class="header" href="#types-of-zero-knowledge-proofs">Types of Zero knowledge proofs</a></h4>
<p>There are two types of zero knowledge proofs (interactive and non interactive ones)
Interactive zero-knowledge proof systems were first introduced in 1985 by Goldwasser, Micali and Rackoff. Non-interactive schemes were introduced later on by Blum et al. The main difference between both schemes is that interactive proofs require interaction between both parties which means both have to be online in order to do so; this can be seen as inconvenient, especially for modern cryptography applications, while non-interactive proofs need a shared setup preprocessing phase instead. The shared setup phase will allow the participating parties to know which statement is being proved and what protocol is being used.</p>
<h4 id="interactive-zero-knowledge-proofs"><a class="header" href="#interactive-zero-knowledge-proofs">Interactive Zero Knowledge Proofs</a></h4>
<p>A prover $P$ has a secret $s$ and correctly responds to challenges to convince a verifier $V$ it has knowledge of $s$ using rounds of interaction between the two parties.</p>
<h4 id="non-interactive-zero-knowledge-proofs-nizk"><a class="header" href="#non-interactive-zero-knowledge-proofs-nizk">Non interactive zero knowledge proofs (NIZK)</a></h4>
<p>Non-interactive zero-knowledge proofs, also known as NIZKs are another type of zero-knowledge proof which require no interaction between the prover and the verifier. 
In order to transform interactive proofs into NIZK proofs, cryptographers used the Fiat-Shamir heuristic hash function. This hash function allows one to compute the verifier challenges and offer very efficient NIZK arguments that are secure in the random oracle model. More recent works have started using bilinear groups to improve efficiency.</p>
<p>The two major types of NIZK proofs are zkSNARKs and zkSTARKs; zkSNARKs are based on elliptic curve cryptography and need a trusted setup phase, whereas zkSTARKs rely on hash functions and do not have any trusted setup. 
We will focus on zkSNARKs since PLONK is in this category.</p>
<p>zkSNARKs stands for zero-knowledge Succinct Non-interactive ARguments of Knowledge. </p>
<ul>
<li>Succinct: proof length needs to be short</li>
<li>Non-interactive: needs to be verifiable in a short amount of time</li>
<li>ARKs: need to show that we know an input (witness) which yields to a certain computation. </li>
</ul>
<p>zkSNARKs cannot be applied to any computational problem directly; rather, you have to convert the problem into the right “form” for the problem to operate on. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plonk"><a class="header" href="#plonk">PLONK</a></h1>
<p>PLONK stands for Permutations over Lagrange-bases for Oecumenical Non Interactive Arguments of Knowledge.</p>
<p>PLONK is a general-purpose zero-knowledge proof scheme which solves a huge issue inherited in traditional zksnarks proof systems like Groth16: the one-time trusted setup.
The trusted setup is a preprocessing phase which creates a Structured Reference String (SRS) that is available to both prover and verifier. The reason why SRS is created is to prevent the prover from cheating and creating fake proofs and thus fulfilling the soundness property. The problem with one-time trusted setup is that it’s a one-time event which means every circuit needs a new SRS to be generated which results in slow verification time.  PLONK solves this problem by creating a single SRS that’s used for an unlimited number of arbitrary circuits (of a certain maximum size). This string is also updatable which improves security.</p>
<h2 id="plonk-components"><a class="header" href="#plonk-components">PLONK components</a></h2>
<p>PLONK can be constructed as follow:</p>
<p>Program (code)→ Arithmetic circuit → Constraint systems → Permutation checks → Polynomial commitments (A batched version of KZG10)</p>
<p>We will use the following example to be able to explain each step and the transition from one to the other. For a more detailed explanation, please check the <a href="https://eprint.iacr.org/2019/953.pdf">original PLONK paper</a> as it contains formal definitions and some interesting insights regarding efficiency etc.</p>
<p><strong>Problem definition:</strong></p>
<p>Prover wants to prove to Verifier that she knows the solution to the equation:
$$x^3+x+5=0$$</p>
<p>The goal is for Prover to evaluate the above function without revealing anything about the secret value x (solution to the equation). </p>
<p>Prover creates a program to represent the problem in a function code which then will be translated into an arithmetic circuit.</p>
<h3 id="arithmetic-circuit"><a class="header" href="#arithmetic-circuit">Arithmetic circuit</a></h3>
<p>This step transforms a program into an arithmetic circuit where two basic components: are being used: wires and gates. Plonk uses fan-in two gates, therefore each gate has a left input, a right input and an output. A circuit with n gates will have $3n$ wires. </p>
<p>PlonK is gate-based instead of R1CS-based like some proof systems like Groth16. The difference between both systems is in how they handle addition gates, in R1CS addition gates are cheap as  wires that are going from an addition to multiplication gate are not labeled which is not the case for a gate-based system. The reason why PLONK uses a gate-based instead of a R1CS fan-in;  and  thus  our  linear constraints  are  just  wiring  constraints  that  can  be reduced to a permutation check. To understand more the advantages and disadvantages of each of those designs check this <a href="https://hackmd.io/@aztec-network/plonk-arithmetiization-air#How-does-all-this-relate-to-R1CS">article</a>.</p>
<p>The following circuit translates the previous equation $x^3+x+5=0$ where we have 2 multiplication gates and 2 addition gates. </p>
<p align="center">
  <img  alt="circuit" width="250"src="images/images/circuit.png" />
</p>
<h3 id="constraint-system"><a class="header" href="#constraint-system">Constraint system</a></h3>
<p>The circuit is converted into a system of equations where the variables are the values on all the wires and there is one equation per gate. Let’s take our previous example:</p>
<p>$\begin{equation*}
\begin{dcases}
\begin{align}
a_1<em>b_1-c_1 &amp;=0 &amp; \
a_2</em>b_2-c_2 &amp;=0 &amp;\
a_3+b_3-c_3&amp;=0 &amp;\
a_4+b_4-c_4&amp;=0 
\end{align}
\end{dcases}
\end{equation*}$</p>
<p>The final result is  $x^3+x+5-c_4=0$ which represents the program we wanted to solve for $c_4=x^3+x+5=0$.
The setup for each of those equations is of the form:
$$(Q_{L_i})a_i + (Q_{R_i})b_i +(Q_{O_i})c_i + (Q_{M_i})a_ib_i  + Q_{C_{i}} =0$$</p>
<p>for  $L$= left, $R$ = right, $O$= output, $M$= multiplication, $C$= constant
The arithmetic gates are modeled with the selector vectors:  $(Q_L,Q_R,Q_O,Q_C,Q_M)$</p>
<p>Each $Q$ value is a constant. We define $Q$ for an additive gate and a multiplicative one and a constant gate as follow:<br />
For an addition gate, we set:
$$Q_{L_i}=1, Q_{R_i}=1,Q_{M_i}=0,Q_{O_i}=-1,Q_{C_i}=0$$
For a multiplication gate, we set:
$$Q_{L_i}=0, Q_{R_i}=0,Q_{M_i}=1,Q_{O_i}=-1,Q_{C_i}=0$$</p>
<p>For a constant gate setting $a_i$ to some constant $x$, we set:
$$Q_{L_i}=1, Q_{R_i}=0,Q_{M_i}=0,Q_{O_i}=0,Q_{C_i}=-x$$</p>
<p>There are two types of constraints:</p>
<ol>
<li>
<p><strong>Gate constraints:</strong> Which represents the equations between the wires attached to the same gate. For example the equation $(1)$:  $$a_1*b_1-c_1=0 $$</p>
</li>
<li>
<p><strong>Copy constraints:</strong>  PLONK enforces copy constraints which associate wires that are equal from the whole circuit so that the output of one circuit is indeed the input of the next one. These constraints are checked with a permutation argument. For example, $c_1$ the output of equation $(1)$ is also an input for another gate, we copy that constraint into a new one $a_2$ and we claim equality $c_1=a_2$</p>
</li>
</ol>
<h3 id="permutation-checks"><a class="header" href="#permutation-checks">Permutation checks</a></h3>
<p>We introduce a permutation argument  used to assure the correct execution of the circuit. It allows to check the connection between different wires inside of the circuit and make sure that the output of a certain circuit is equal to the input of another for example $(c_2=b_3)$  where $c_2$ is the output of circuit $2$ and $b_3$ is the right input of circuit $3$.</p>
<p>Let $\phi_1,..........,\phi_k \in F_{&lt;d}[X]$ and $\sigma :[kn]\rightarrow [kn] $ for $k$ = number of wires. We say for a set of polynomials $(g_1,.......,g_k) \in (F_{&lt;d}[X])^k$ that $$(g_1,g_2,........,g_k)=\sigma(\phi_1,...........,\phi_k)$$ if the following holds:</p>
<p>$g_{(l)}=\phi_{(\sigma(l))}$  for $l \in [kn]$  where $\phi_{((j-1).n+i)}=\phi_j(w^i), g_{((j-1).n+i)}=g_j(w^i)$</p>
<p>for each $j\in [k], i\in [n]$</p>
<p>The prover will be able to select an appropriate $\sigma$ for a set of wire connections and the
verifier will be convinced that the connections are correct by checking the permutation argument on the set of polynomials with itself:</p>
<p>$$
(\phi_1,\dots,\phi_k) = \sigma((\phi_1,\dots,\phi_k))
$$</p>
<p>Note that if this equality holds, we can substitute $(\phi_1,\dots,\phi_k)$ in the right hand side indefinitely as so:</p>
<p>$$
(\phi_1,\dots, \phi_k)=\
\sigma((\phi_1,\dots, \phi_k)) =\
\sigma( \sigma((\phi_1, \dots, \phi_k)) ) = \dots
$$</p>
<p>and therefore the check effectively assures that</p>
<p>$$
(\phi_1, \dots, \phi_k) = \sigma^i((\phi_1, \dots, \phi_3))
$$
for all $i \in \mathbb{N}$.</p>
<h3 id="kzg10-batched-commitments"><a class="header" href="#kzg10-batched-commitments">KZG10 Batched commitments:</a></h3>
<p>PLONK uses a batched kate commitment form in order to improve verifier efficiency by allowing for a parallel opening of commitments for each evaluation point possible. 
Let’s take $t$ polynomials of degree $\leq d;$. Let $F$ be a field of prime order. We denote by $F_{&lt;d}[X]$ the set of polynomials over $F$ of degree $&lt;d$. Let $G_1,G_2,G_t$ be groups of size $r$ and $e:G_1\times G_2\rightarrow G_t$ a bilinear pairing such that $e(g_1,g_2)=g_t$ with $g_1,g_2$ generators of $G_1$ and $G_2$ respectively.</p>
<h5 id="definition-8"><a class="header" href="#definition-8">Definition:</a></h5>
<p>d-polynomial commitment scheme is a setting of $t$ polynomials $\phi_1,\phi_2,.......,\phi_t\in F_{&lt;d}[x]$ of degree $d$ each such that $z_1,z_2,..........,z_t\in F$ are evaluation points for those polynomials. The alleged commitments to polynomials are $cm_1,cm_2,......,cm_t$ where $cm_i=com(\phi_i,srs)$ for $i\in[t]$ and alleged correct openings $s_1,s_2,.........,s_t$.</p>
<p>The commitment scheme has three steps as follow:</p>
<ul>
<li>$gen(d)$: this step will generate a structured reference string $(srs)$ in a randomized way. The algorithm chooses randomly $x\in F$ and outputs</li>
</ul>
<p>$$srs=([1]_1,[x]_1,[x^2]_1,[x^3]_1,.............[x^{d-1}]_1,[1]_2,[x]_2)$$
where   $[x]_1 =x.g_1$  and   $x_2=x.g_2$ </p>
<ul>
<li>
<p>$com(,srs)$: the commitment is computed as follow
$$com(,srs):=[\phi(x)]_1$$ </p>
</li>
<li>
<p>$open:$ we take in consideration two scenarios:</p>
<ol>
<li>
<p>All evaluation points are equal $z_1=z_2=........=z_t=z$ $$open({cm_i},{z_i},{s_i})$$ for $i \in [t]$</p>
<p>a. Verifier sends a random $\gamma\in F$</p>
<p>b. Prover computes $$h(x)=\sum_{i=1}^{t}\gamma^{i-1}.\dfrac{\phi_i(x)-\phi_i(z)}{x-z}$$ and then uses $srs$ to compute the commitment $W$ and send it to verifier $$W=h[(x)]_1$$</p>
</li>
</ol>
<p>c.  Verifier computes the following:
$$F=\sum_{i\in[t]}\gamma^{i-1}.cm_i ;and;      v=[\sum_{i\in[t]}\gamma^{i-1}.s_i]_1$$
and accepts iff $$e(F-v,[1]_2).e(-W,[x-z]_2)=1$$</p>
</li>
</ul>
<ol start="2">
<li>Let $z,z'$ be two distinct evaluation points and $t_1,t_2$ be the number of polynomials
We will describe the protocol when there are two distinct points among $z_1,\dots, z_t$. Let $z, z'$
be the distinct evaluation points and $t_1,t_2$ then number of polynomials ${f_i}<em>{i\in [t_1]},
{f_i'}</em>{i\in [t_2]}$ evaluated in $z, z'$ respectively.</li>
</ol>
<p>Note that these protocols are not zero-knowledge. The notion of zero-knowledge is not even well defined for polynomial commitments. At the end, when we present the full protocol we
will add blinders to add the zero-knowledge property to the Plonk protocol.</p>
<ol start="3">
<li>$open( {cm_i}<em>{i \in [t_1]},{cm_i'}</em>{i \in [t_2]}, z, z', {s_i}<em>{i \in [t_1]} {s_i'}</em>{i \in [t_2]})$
<ol>
<li>Verifier sends random challenges $\gamma, \gamma' \in \mathbb{F}$</li>
<li>Prover computes polynomials
$$
h(X) := \sum_{i=1}^{t_1} \gamma^{i-1} \frac{f_i(X) - f_i(z)}{X-z}\
h'(X):= \sum_{i=1}^{t_2} \gamma'^{i-1} \frac{f'_i(X) - f'_i(z')}{X-z'}
$$
and sends commitments $W=[h(x)]_1, W'=[h'(x)]_1$.</li>
<li>Verifier chooses random $r' \in \mathbb{F}$ and computes
$$
F:= \left( \sum_{i=1}^{t_1} \gamma^{i-1} \cdot cm_i -
\left[ \sum_{i=1}^{t_1} \gamma^{i-1} s_i \right]<em>1\right) +\
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot cm'<em>i -
\left[ \sum</em>{i=1}^{t_2} \gamma'^{i-1} s'_i \right]_1\right)
$$</li>
<li>Verifier accepts iff
$$
e(F +z \cdot W + r'z'\cdot W', [1]_2) =
e(W + r'\cdot W', [x]_2)
$$</li>
</ol>
</li>
</ol>
<p>Extending the right side of the check we get
$$
e(F +z \cdot W + r'z'\cdot W', [1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot cm_i -
\left[ \sum_{i=1}^{t_1} \gamma^{i-1} s_i \right]<em>1\right) +
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot cm'<em>i -
\left[ \sum</em>{i=1}^{t_2} \gamma'^{i-1} s'_i \right]<em>1\right)\ +
z \cdot \sum</em>{i=1}^{t_1} \gamma^{i-1} \frac{[f_i(x) - f_i(z)]<em>1}{x-z} +\
r'z' \cdot \sum</em>{i=1}^{t_2} \gamma'^{i-1} \frac{[f'_i(x) - f'_i(z')]_1}{x-z'}, [1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot [f_i(x)]<em>1 -
\left[ \sum</em>{i=1}^{t_1} \gamma^{i-1} f_i(z) \right]<em>1\right) +
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot [f'_i(x)]<em>1 -
\left[ \sum</em>{i=1}^{t_2} \gamma'^{i-1} f'_i(z) \right]<em>1\right)\ +
z \cdot \sum</em>{i=1}^{t_1} \gamma^{i-1} \frac{[f_i(x) - f_i(z)]<em>1}{x-z} +\
r'z' \cdot \sum</em>{i=1}^{t_2} \gamma'^{i-1} \frac{[f'_i(x) - f'_i(z')]_1}{x-z'}, [1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot
[f_i(x) - f_i(z)]<em>1 \right) +
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot
[f'_i(x) - f'_i(z)]<em>1 \right)\ +
z \cdot \sum</em>{i=1}^{t_1} \gamma^{i-1}
\frac{[f_i(x) - f_i(z)]<em>1}{x-z} +\
r'z' \cdot \sum</em>{i=1}^{t_2} \gamma'^{i-1}
\frac{[f'_i(x) - f'_i(z')]_1}{x-z'}, [1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot
[f_i(x) - f_i(z)]<em>1 \right) (1 + \frac{z}{x-z}) +\
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot
[f'_i(x) - f'_i(z)]_1 \right) (1 + \frac{z'}{x-z'}),
[1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot
[f_i(x) - f_i(z)]<em>1 \right) (\frac{x}{x-z}) +\
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot
[f'_i(x) - f'_i(z)]_1 \right) (\frac{x}{x-z'}),
[1]_2)
$$</p>
<p>From the left side we get
$$
e(W + r' \cdot W', [x]<em>2) =\
e( \sum</em>{i=1}^{t_1} \gamma^{i-1}
\frac{[f_i(x) - f_i(z)]<em>1}{x-z}\ +
r' \cdot \sum</em>{i=1}^{t_1} \gamma'^{i-1}
\frac{f'_i(x) - f'_i(z')}{x-z'} , [x]_2)
$$</p>
<h2 id="plonk-protocol"><a class="header" href="#plonk-protocol">PLONK protocol</a></h2>
<p><strong>Common preprocessed input:</strong></p>
<p>The prover only uses the $\mathbb{G}_1$ part of the srs,
therefore the $\mathbb{G}_2$ part is part of the verifier
preprocessed input</p>
<p>$$
n,\
srs \rightarrow ([x]<em>1, [x^2]<em>1,\dots,[x^{n+2}]<em>1),\ 
(q_M, q_L, q_R, q_O, q_C)</em>{i=1}^n \rightarrow
\begin{cases}
q_M(X) = \sum</em>{i=1}^n q</em>{Mi} L_i(X)\
q_L(X)= \sum_{i=1}^n q_{Li} L_i(X),\
q_R(X)= \sum_{i=1}^n q_{Ri} L_i(X),\
q_O(X)= \sum_{i=1}^n q_{Oi} L_i(X),\
q_C(X)= \sum_{i=1}^n q_{Ci} L_i(X),
\end{cases}\
\sigma(X) \rightarrow
\begin{cases}
S_{\sigma_1}(X) = \sum_{i=1}^n \sigma(i) L_i(X),\
S_{\sigma_2}(X) = \sum_{i=1}^n \sigma(n+i) L_i(X),\
S_{\sigma_3}(X) = \sum_{i=1}^n \sigma(2n+i) L_i(X),\
\end{cases}\
$$</p>
<p>The public input values will be written as part of the set of wires.
Having $l$ wires as public inputs: $$l, (w_i)_{i \in [l]}$$</p>
<h3 id="prover-algorithm"><a class="header" href="#prover-algorithm">Prover Algorithm</a></h3>
<p>The prover input is the set of values assigned to each wire:</p>
<p><strong>Prover input:</strong> $(w_i)_{i \in [3n]}$</p>
<p><strong>Round 1</strong> -- Commit to wire values.</p>
<p>Generate random blinding scalars $(b_1,\dots,b_9) \in \mathbb{F}<em>p$
Compute wire polynomials
$$
a(X) = (b_1 X + b_2)Z_H(X) + \sum</em>{i=1}^n w_i L_i(X)\
b(X) = (b_3 X + b_4)Z_H(X) + \sum_{i=1}^n w_{n+i} L_i(X)\
c(X) = (b_5 X + b_6)Z_H(X) + \sum_{i=1}^n w_{2n+i} L_i(X)
$$</p>
<p>Compute commitments:
$$
[a]_1 := [a(x)]_1,
[b]_1 := [b(x)]_1,
[c]_1 := [c(x)]_1
$$</p>
<p>Output $([a]_1, [b]_1, [c]_1).$</p>
<p><strong>Round 2</strong> -- Permutation polynomial</p>
<p>Compute challenges $\beta, \gamma \in \mathbb{F}_p$:
$$
\beta = hash(Transcript,0),\
\gamma = hash(Transcript,1)
$$</p>
<p>Compute permutation polynomial $z(X)$:
$$
z(X) = (b_7  X^2 +b_8  X +b_9 )Z_H(X) +\
L_1(X) +
\sum_{i=1}^n \left(
L_{i+1}(X) \prod_{j=1}^i
\frac{  (\omega_j +\beta\omega^{j-1}+\gamma)
(\omega_{n+j} + \beta k_1 \omega^{j-1} +\gamma)
(\omega_{2n+j}+ \beta k_2 \omega^{j-1} +\gamma)}
{  (\omega_j +\beta \sigma(j) +\gamma)
(\omega_{n+j} + \beta \sigma(n+j) +\gamma)
(\omega_{2n+j}+ \beta \sigma(2n+j) +\gamma)}
\right)
$$</p>
<p>Compute $[z]_1 := [z(x)]_1$</p>
<p>Output $[z]_1$</p>
<p><strong>Round 3</strong></p>
<p>Compute quotient challenge $\alpha \in \mathbb{F}_p$
$$
\alpha = hash(Transcript)
$$</p>
<p>Compute quotient polynomial $t(X)$:
$$
t(X) :=\
\frac{1}{Z_H(X)} (a(X)b(X)q_M(X) +
a(X)q_L(X) +
b(X)q_R(X) +
c(X)q_O(X) +
PI(X) +
q_C(X)) +\
\frac{\alpha}{Z_H(X)} ((a(X) + \beta X + \gamma)
(b(X) + \beta k_1 X + \gamma)
(c(X) + \beta k_2 X + \gamma)
z(X)) -\
\frac{\alpha}{Z_H(X)} ((a(X) + \beta S_{\sigma_1}(X) + \gamma)
(b(X) + \beta S_{\sigma_2}(X) + \gamma)
(c(X) + \beta S_{\sigma_3}(X) + \gamma)
z(X \omega)) +\
(z(X) - 1)L_1(X)\frac{\alpha^2}{z_H(X)}
$$</p>
<p>Note that all terms of the polynomial are divided by $Z_H(X)$. This can be done because if all the constraints hold the then the polynomials are 0 in all elements of H, and therefore, divisible by $Z_H(X)$</p>
<p>Split $t(X)$ into $&lt;n$ degree polynomials
$t_{lo}(X), t_{mid}(X), t_{hi}(X)$ so that:</p>
<p>$$
t(X) = t_{lo}(X) + X^n t_{mid}(X) + X^{2n} t_{hi}(X) +
$$</p>
<p>Compute $[t_{lo}]<em>1 := [t</em>{lo}(x)]<em>1$,
$[t</em>{mid}]<em>1 := [t</em>{mid}(x)]<em>1$,
$[t</em>{hi}]<em>1 = [t</em>{hi}(x)]_1$</p>
<p>Output $([t_{lo}]<em>1, [t</em>{mid}]<em>1, [t</em>{hi}]_1)$</p>
<p><strong>Round 4</strong></p>
<p>Compute evaluation challenge $\zeta \in \mathbb{F}_p$:
$$
\zeta = hash(Transcript)
$$</p>
<p>Compute opening evaluations at $\zeta$:
$$
\bar{a}:= a(\zeta),
\bar{b}:= b(\zeta),
\bar{c}:= c(\zeta),\
\bar{s}<em>{\sigma_1} := S</em>{\sigma_1}(\zeta),
\bar{s}<em>{\sigma_2} := S</em>{\sigma_2}(\zeta),\
\bar{t} := t(\zeta),
\bar{z}_{\omega} := z(\omega\zeta),
$$</p>
<p>Compute linearisation polynomial $r(X)$:
$$
r(X) = 
(
\bar{a}\bar{b} \cdot q_M(X) +
\bar{a} \cdot q_L(X) +
\bar{b} \cdot q_R(X) +
\bar{c} \cdot q_O(X) +
q_C(X)
) + \
(
(\bar{a} + \beta \zeta + \gamma)
(\bar{b} + \beta k_1 \zeta + \gamma)
(\bar{c} + \beta k_2 \zeta + \gamma)
) \cdot z(X) \alpha - \
(
(\bar{a} + \beta \bar{s}<em>{\sigma_1} + \gamma)
(\bar{b} + \beta \bar{s}</em>{\sigma_2} + \gamma)
\beta\bar{z}<em>\omega \cdot S</em>{\sigma_3}(X)
)\alpha + \
z(X)L_1(\zeta)\alpha^2
$$</p>
<p>Compute linearisation evaluation at $\zeta$:
$$
\bar r:= r(\zeta)
$$</p>
<p>Output ($\bar{a}, \bar{b},\bar{c},
\bar{s}<em>{\sigma_1}, \bar{s}</em>{\sigma_2},
\bar{z}_\omega, \bar{t}, \bar{r}$)</p>
<p><strong>Round 5</strong></p>
<p>Compute opening challenge $v \in \mathbb{F}_p$:
$$
v = hash(Transcript)
$$</p>
<p>Compute opening proof polynomial $W_\zeta(X)$:</p>
<p>$$
W_\zeta(X)=
\frac{1}{X - \zeta}
\left(
(
t_{lo}(X) +
\zeta^n t_{mid}(\zeta) +
\zeta^{2n} t_{hi}(\zeta)-
\bar{t}
) +\
v(r(X) - \bar r) +\
v^2(a(X) - \bar a) +\
v^3(b(X) - \bar b) +\
v^4(c(X) - \bar c) +\
v^5(S_{\sigma_1} - \bar s_{\sigma_1}) +\
v^6(S_{\sigma_2} - \bar s_{\sigma_2}) 
\right)
$$</p>
<p>Compute opening proof polynomial</p>
<p>$$
W_{\zeta \omega}(X) = 
\frac{(z(X) - \bar z_\omega)}{X - \zeta\omega}
$$</p>
<p>Compute $[W_\zeta]<em>1:=[W</em>\zeta(x)],
[W_{\zeta \omega}]<em>1:=[W</em>{\zeta \omega}(x)]$</p>
<p>Return 
$$
\pi_{SNARK} = 
([a]_1, [b]<em>1, [c]<em>1, [z]<em>1,
[t</em>{lo}]<em>1, [t</em>{mid}]<em>1, [t</em>{hi}]<em>1,
[W</em>\zeta]<em>1, [W</em>{\zeta \omega}]<em>1, \
\bar{a}, \bar{b}, \bar{c},
\bar s</em>{\sigma_1}, \bar s</em>{\sigma_2},
\bar{r}, \bar z</em>\omega
)
$$</p>
<p>Compute multipoint evaluation challenge $u \in \mathbb{F}_p$:
$$
u := hash(Transcript)
$$</p>
<h3 id="verifier-algorithm"><a class="header" href="#verifier-algorithm">Verifier Algorithm</a></h3>
<p><strong>Verifier preprocessed input:</strong></p>
<p>$$[q_M]_1 := [q_M(x)]<em>1,[q_L]<em>1 := [q_L(x)<em>1,[q_R]<em>1 := [q_R(x)]<em>1,$$
$$[q_O]<em>1 := [q_O(x)]<em>1,[q_C]<em>1 := [q_C(x)]<em>1,[s</em>{\sigma</em>{1}}]<em>1 := [S</em>{\sigma</em>{1}}(x)],$$
$$[s</em>{\sigma</em>{2}}]<em>1 := [S</em>{\sigma</em>{2}}(x)],[s</em>{\sigma</em>{3}}]<em>1 := [S</em>{\sigma</em>{3}}(x)],([1]_2, [x]_2)$$</p>
<p><strong>Verifier input:</strong> $(w_i)<em>{[l]}, \pi</em>{SNARK}$</p>
<ol>
<li>
<p>Validate $([a]_1, [b]_1, [c]_1, [z]<em>1,
[t</em>{lo}]<em>1, [t</em>{mid}]<em>1, [t</em>{hi}]_1,
[W_z]<em>1, [W</em>{z \omega}]_1 ) \in \mathbb{G}_1$</p>
</li>
<li>
<p>Validate $(\bar a, \bar b, \bar c,
\bar s_{\sigma_1}, \bar s_{\sigma_2},
\bar z, \bar z_\omega) \in \mathbb{F}_p^7$</p>
</li>
<li>
<p>Validate $(w_i)({i \in [l]}) \in \mathbb{F}_p^l$</p>
</li>
<li>
<p>Compute challenges from common input public input and the elements of $\pi_{SNARK}$: $\beta, \gamma, \alpha, \zeta, v, u \in \mathbb{F}_p$</p>
</li>
<li>
<p>Compute $Z_H(\zeta) = \zeta^n -1$</p>
</li>
<li>
<p>Compute $L_1(\zeta) = \frac{\omega (\zeta^n - 1)}{n (\zeta - \omega)}$</p>
</li>
<li>
<p>Compute Public input polynomial evaluation
$PI(\zeta) = \sum_{i\in[l]} w_i L_i(\zeta)$</p>
</li>
<li>
<p>Compute quotient polynomial evaluation
$$
\bar t = 
\frac{
\bar r +
PI(\zeta) -
(
(\bar a + \beta \bar s_{\sigma_1} + \gamma)
(\bar b + \beta \bar s_{\sigma_2} + \gamma)
(\bar c + \gamma) \bar z_\omega
) \alpha -
L_1(\zeta) \alpha^2
}{
Z_H(\zeta)
}
$$</p>
</li>
<li>
<p>First part of batched polynomial commitment
$[D]_1 := v \cdot [r]_1 + u\cdot [z]_1$:
$$ v (\bar a \bar b [q_M]_1 +\bar a [q_L]_1 +\bar b [q_R]_1 +\bar c [q_O]<em>1 +[q_C]<em>1 )+$$
$$[z]<em>1 ((\bar a + \beta \zeta + \gamma)(\bar b + \beta k_1 \zeta + \gamma)(\bar c +<br />
\beta k_2 \zeta + \gamma)\alpha v + L_1(\zeta)\alpha^2 v +u)$$
$$ - (\bar a + \beta \bar s{\sigma_1} \zeta + \gamma)(\bar b + \beta \bar s</em>{\sigma_2} \zeta + \gamma)\alpha v\beta \bar z</em>\omega[s</em>{\sigma_3}]_1$$ </p>
</li>
<li>
<p>Compute the fully batched polynomial commitment $[F]_1$:
$$
[F]<em>1 :=
[t</em>{lo}]<em>1 +
\zeta^n [t</em>{mid}]<em>1 +
\zeta^{2n} [t</em>{hi}]_1  + 
[D]_1 +
v^2 \cdot [a]_1 +
v^3 \cdot [b]_1 +
v^4 \cdot [c]<em>1 +
v^5 \cdot [s</em>{\sigma_1}]<em>1 +
v^6 \cdot [s</em>{\sigma_2}]_1
$$</p>
</li>
<li>
<p>Compute group-encoded bath evaluation $[E]<em>1$:
$$
[E]<em>1 := 
\left[
\bar t +
v \bar r +
v^2 \bar a +
v^3 \bar b +
v^4 \bar c +
v^5 \bar s</em>{\sigma_1} +
v^6 \bar s</em>{\sigma_2} +
u \bar z_\omega
\right]_1
$$</p>
</li>
<li>
<p>Batch validate all evaluations 
$$
e(
[W_\zeta]<em>1) +
u \cdot [W</em>{\zeta \omega}]_1),
[x]<em>2
)
\stackrel{?}{=}
e(
\zeta \cdot [W</em>\zeta]<em>1) +
u \zeta \omega \cdot [W</em>{\zeta \omega}]_1) +
[F]_1 - [E]_1,
[1]_2
)
$$</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ark-plonk-library"><a class="header" href="#ark-plonk-library">ARK-PLONK library</a></h1>
<p>ARK-PLONK is a generic Rust PLONK implementation using arkworks as a backend. ARK-PLONK is one of many projects implementing PLONK like: TurboPlonk, UltraPlonk. DuskPlonk, Plonky, ShPlonk, PLOOKUP, PLONKUP, halo2...etc.</p>
<p>ARK-PLONK is however the only generic implementation which allows any curve implementation or commitment scheme to be used and isn’t restricted to only one implementation like other existing libraries (for example duskPlonk is based on bls12-281).</p>
<h2 id="state-of-the-art"><a class="header" href="#state-of-the-art">State of the art</a></h2>
<p>In 2020, AZTEC team has developed PLONK which uses KZG's pairing-based polynomial commitment scheme in order to bring a universal zkSNARK setup. 
Since then, PLONK has become very popular and lots of projects like Dusk Network, Zcash's Halo 2, Mina, Mir...etc started using it and developing their own variations of it. 
Both Mir and Zcash use PLONK combined with <a href="https://eprint.iacr.org/2019/1021.pdf">Halo’s polynomial commitment scheme</a> for their libraries <a href="https://github.com/mir-protocol/plonky">Plonky</a> and Halo2. Halo based schemes do recursive proofs without pairings using elliptic curves that are not pairing friendly and can run without the need for trusted setups. In a recursive proof, the verifier is written inside the circuit which allows us to verify a proof inside of another proof while in a standard proof system there is a prover and a verifier. 
In a KZG system, the proof size is very small (less than a kilobyte) and it's constant and also the verification time is constant, it’s also easy to verify on Ethereum but recursion is hard to do with pairings. 
Halo based schemes have decent proof size and prover time, but take linear time to verify and it’s not possible to verify on Ethereum.</p>
<p>Mir has recently developed a more optimized proving system Plonky2 based on PLONK and FRI. 
FRI-based ZK-STARKs algorithm provides both quantum-resistance and does not require any trusted setups while the KZG scheme uses elliptic curve pairing which is not quantum resistant and requires a third-party trusted setup. FRI has a blowup factor which measures how much redundancy a polynomial needs to add before the commitment is generated and thus makes the prover faster. 
Plonky2 claims a 100x speed up for ethereum for $170ms$ comparing to Plonky which takes $15s$ for proving times. 
ARK-PLONK is an optimization of the original PLONK protocol and guarantees $3.44s$ for proving time and $4.50ms$ for verifier speed comparing to $60$ proof times in the original PLONK design.</p>
<p>A differentiating factor ARK-PLONK has is the fact that it uses Arkworks generic backend, a rust library that abstracts over the curves and over the fields so you can use any algorithm in a generic way. This makes ARK-PLONK valid for any curve implementation for pairing curves, for edwards twisted curves….etc.<br />
ARK-PLONK also uses a generic polynomial commitment based on <a href="https://docs.rs/ark-poly-commit/0.3.0/ark_poly_commit/">ark-poly-commit</a> which provides various constructions of polynomial commitment schemes. This will allow ARK-PLONK to use other commitment schemes like quantum resistent FRI and not be restricted only to KZG10.</p>
<p>There is no other library right which allows you to have the freedom of using generic parameters. Zcash's Halo2 and Plonky use HALO commitment scheme while plonky2 uses only FRI scheme. In terms of elliptic curves, Aztek's implementation of PLonk is based on bn256, duskPlonk is based on bls12-281.</p>
<h2 id="circuit-implementation"><a class="header" href="#circuit-implementation">Circuit implementation</a></h2>
<p>ARK-PLONK's implementation is an optimization of the original PLONK protocol as it enables lookup table to the PLONK circuit. This optimization allows for precomputation of some of the operations that are not snark friendly like bit operations (see <a href="https://eprint.iacr.org/2020/315.pdf">PLOOKUP</a> for further explanation on PLONK + LOOKUP tables).</p>
<p>Our implementation also uses custom gates similarly to <a href="https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf">TurboPolnk</a> which allow us to define our own custom bit arithmetic operations like efficient Poseidon or MIMC hashes which are extremely efficient to evaluate inside of a snark. </p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<ul>
<li>
<p>circuit: Tools &amp; traits for PLONK circuits (ark_plonk::circuit)</p>
<ol>
<li>Structs
<ul>
<li><code>PublicInputValue</code>: structure that represents a PLONK Circuit Public Input converted into its scalar representation.</li>
<li><code>VerifierData</code>: Collection of structs/objects that the Verifier will use in order to de/serialize data needed for Circuit proof verification. This structure can be seen as a link between the Circuit public input positions and the VerifierKey that the Verifier needs to use.</li>
<li><code>TestCircuit</code>: structure of a circuit that checks the following:
<ol>
<li>$a + b = c$ where $c$ is a PI</li>
<li>Checks $a$ and $b$ are in range</li>
<li>$a * b = d$ where $d$ is a PI</li>
<li>JubJub::GENERATOR * $e$(JubJubScalar)= $f$ where $f$ is a PI</li>
</ol>
</li>
</ul>
</li>
<li>Traits 
<ul>
<li>
<p><code>Circuit</code>: Allows to automatically being able to generate, and verify proofs as  well as compile the circuit.</p>
</li>
<li>
<p><code>FeIntoPubInput</code>: Field Element Into Public Input</p>
</li>
<li>
<p><code>GeIntoPubInput</code>: Group Element Into Public Input</p>
<p>The two traits <code>FeIntoPubInput</code> and <code>GeIntoPubInput</code> are helper traits used as a way to have a workaround for not being able to implement <code>From&lt;_&gt; for Values</code> for both <code>PrimeField</code> and <code>GroupAffine</code> since they are external to the crate, and therefore the compiler cannot be sure that <code>PrimeField</code> will never be implemented for <code>GroupAffine</code>. In which case, the two implementations would be inconsistent. </p>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>constraint_system: The constraint System module stores the implementation of the PLONK Standard Composer, as well as the circuit tools and abstractions, used by the Composer to generate, build, preprocess circuits.</p>
</li>
<li>
<p>proof_system: Proving system</p>
</li>
<li>
<p>error: Defines all possible errors that can be encountered in PLONK</p>
</li>
<li>
<p>prelude: collection of functions needed to use ark-plonk library.</p>
<ul>
<li>Structs:
<ul>
<li><code>Circuit</code></li>
<li><code>PublicInputValue</code></li>
<li><code>VerifierData</code></li>
<li><code>StandardComposer</code>: A StandardComposer stores all of the circuit information (values, positions in the circuits, gates and Wires that occupy, public inputs, Permutation argument...etc)</li>
<li><code>Proof</code>: A Proof is a composition of Commitments to the Witness, Permutation, Quotient, Shifted and Opening polynomials as well as the ProofEvaluations.</li>
<li><code>VerifierKey</code>: PLONK circuit Verification Key.</li>
<li><code>Prover</code>: Abstraction structure designed to construct a circuit and generate Proofs for it.</li>
<li><code>ProverKey</code>: 	PLONK circuit Proving Key.</li>
<li><code>Verifier</code>: Abstraction structure designed verify Proofs.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>transcript: an extension over the Merlin Transcript which adds a few extra functionalities.</p>
<ol>
<li>Structs:</li>
</ol>
<ul>
<li><code>TranscriptWrapper</code>: Wrapper around Transcript</li>
</ul>
<ol start="2">
<li>Traits:</li>
</ol>
<ul>
<li><code>TranscriptProtocol</code>: 	Transcript adds an abstraction over the Merlin transcript For convenience</li>
</ul>
</li>
</ul>
<h3 id="proof-generation"><a class="header" href="#proof-generation">Proof generation</a></h3>
<p>The proof is generated using <code>CircuitInputs</code> and <code>ProverKey</code> as follow:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn gen_proof(
        &amp;mut self,
        u_params: &amp;UniversalParams&lt;E&gt;,
        prover_key: ProverKey&lt;E::Fr, P&gt;,
        transcript_init: &amp;'static [u8],
    ) 
<span class="boring">}
</span></code></pre></pre>
<p>After the circuit is compiled, the prover calls  <code>gen_proof()</code> </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let proof = {
            let mut circuit: TestCircuit&lt;E, P&gt; = TestCircuit {
                a: E::Fr::from(20u64),
                b: E::Fr::from(5u64),
                c: E::Fr::from(25u64),
                d: E::Fr::from(100u64),
                e: P::ScalarField::from(2u64),
                f: point_f_pi,
            };

            circuit.gen_proof(&amp;pp, pk_p, b&quot;Test&quot;)?
        };
<span class="boring">}
</span></code></pre></pre>
<h3 id="prover"><a class="header" href="#prover">Prover</a></h3>
<h3 id="verifier"><a class="header" href="#verifier">Verifier</a></h3>
<p>The Verification does not require a Circuit instance and can be executed solely using <code>verifier_data</code> after the circuit is compiled. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compile the circuit
let (pk_p, verifier_data) = circuit.compile(&amp;pp)?;
<span class="boring">}
</span></code></pre></pre>
<p>The Verifier's data is created from a <code>VerifierKey</code> and the public circuit inputs.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VerifierData&lt;E, P&gt;
where
    E: PairingEngine,
    P: TEModelParameters&lt;BaseField = E::Fr&gt;,
{
    /// Verifier Key
    pub key: VerifierKey&lt;E, P&gt;,

    /// Public Input Positions
    pub pi_pos: Vec&lt;usize&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<h3 id="elliptic-curve"><a class="header" href="#elliptic-curve">Elliptic curve:</a></h3>
<p>Circuits in ARK-PLONK depend on two generic parameters: </p>
<ul>
<li>
<p>The pairing engine which is a pairing friendly curve used for pairing operations and proof verification</p>
</li>
<li>
<p>Twisted Edwards curve: derived from the first one and is used to make elliptic curve operations inside of the circuit.</p>
<p><strong>Example:</strong></p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  pub struct TestCircuit&lt;
    E: PairingEngine,
    P: TEModelParameters&lt;BaseField = E::Fr&gt;,
&gt; {
    a: E::Fr,
    b: E::Fr,
    c: E::Fr,
    d: E::Fr,
    e: P::ScalarField,
    f: GroupAffine&lt;P&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Currently tests are only run with two pairing friendly curves <a href="https://lib.rs/crates/ark-bls12-381">Bls12_381</a> and 
<a href="https://docs.rs/ark-ed-on-bls12-377/0.3.0/ark_ed_on_bls12_377/#">Bls12_377</a> in order to check that the library is generic and can in fact work 
correctly with different parameters and also to measure performance when changing the used curve.</p>
<ul>
<li>
<p>Commitment scheme: The first implementation of ARK-PLONK used the KZG10 commitment scheme which needs a trusted setup as explained in the KZG10 section. However, in order for other projects who don’t wish to have a trusted setup like Mithril for example there is a generic implementation using  <a href="https://docs.rs/ark-poly-commit/0.3.0/ark_poly_commit/">ark-poly-commit</a> library. </p>
</li>
<li>
<p>Signature scheme: 
TBD</p>
</li>
<li>
<p>Hash function:
TBD</p>
</li>
</ul>
<h3 id="gadgets"><a class="header" href="#gadgets">Gadgets</a></h3>
<p>In order to translate a high level code into an arithmetic circuit we need to use gadgets. Gadgets provide modular and reusable abstractions for circuits as well as abstracting functions, elliptic curve points or integers of specific sizes. Some of the most famous zksnarks gadget libraries are Libsnark in C++ and Bellman in Rust.</p>
<p>Every single gadget in ARK-PLONK takes mutable reference or a pointer to the composer which then generates the proof and defines the circuit. </p>
<h4 id="simple-example"><a class="header" href="#simple-example">Simple example</a></h4>
<p>In order to show how our implementation works, we will take a simple example of a gadget $a+b=c$. The gadget proves the knowledge of two private inputs $a$ and $b$ while taking $c$ as a public input.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn gadget(
        &amp;mut self,
        composer: &amp;mut StandardComposer&lt;E, P&gt;,
    ) -&gt; Result&lt;(), Error&gt; {
        let a = composer.add_input(self.a);
        let b = composer.add_input(self.b);
        // Make first constraint a + b = c
        let add_result = composer.add(
          (E::Fr::one(), a),
          (E::Fr::one(), b),
          E::Fr::zero(),
          Some(-self.c),
        );
	composer.assert_equal(add_result, composer.zero_var());

        // Check that a and b are in range
        composer.range_gate(a, 1 &lt;&lt; 6);
        composer.range_gate(b, 1 &lt;&lt; 5);
        // Make second constraint a * b = d
        let mul_result = composer.mul(E::Fr::one(), a, b, E::Fr::zero(), Some(-self.d));
        composer.assert_equal(mul_result, composer.zero_var());

        let e_repr = self.e.into_repr().to_bytes_le();
        let e = composer.add_input(E::Fr::from_le_bytes_mod_order(&amp;e_repr));
        let (x, y) = P::AFFINE_GENERATOR_COEFFS;
        let generator = GroupAffine::new(x, y);
        let scalar_mul_result = composer.fixed_base_scalar_mul(e, generator);
        // Apply the constrain
        composer.assert_equal_public_point(scalar_mul_result, self.f);
        Ok(())
    }

<span class="boring">}
</span></code></pre></pre>
<p>We define three checks that our circuit relies on:</p>
<ul>
<li><strong>Range checks:</strong> $a&lt;26$ and $b&lt;25$</li>
<li><strong>Addition checks:</strong> $a+b=c$</li>
<li><strong>Elliptic curve multiplication</strong> </li>
</ul>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<h2 id="performance"><a class="header" href="#performance">Performance:</a></h2>
<p>To run the benchmarks and get a full report on the performance using your machine </p>
<p><code>RUSTFLAGS='-C target-cpu=native' cargo bench</code></p>
<p>The benchmarks for prover and verifier are done using the <a href="https://bheisler.github.io/criterion.rs/book/criterion_rs.html">Criterion.rs</a> micro-benchmarking tool. Benchmarks are repeated 10 times each and so far only been run with Bls12_381. Benchmarks taken on Intel(R) Core(TM) i9-10885H. Results are in the following table:</p>
<table><thead><tr><th>Circuit size</th><th>Prover speed</th><th>Verifier speed</th></tr></thead><tbody>
<tr><td>$2^5$</td><td>9.5398ms</td><td>4.2881ms</td></tr>
<tr><td>$2^6$</td><td>13.013ms</td><td>4.2781ms</td></tr>
<tr><td>$2^7$</td><td>18.137ms</td><td>4.2973ms</td></tr>
<tr><td>$2^8$</td><td>29.914ms</td><td>4.2593ms</td></tr>
<tr><td>$2^9$</td><td>50.221ms</td><td>4.3023ms</td></tr>
<tr><td>$2^{10}$</td><td>68.704ms</td><td>4.2228ms</td></tr>
<tr><td>$2^{11}$</td><td>127.49ms</td><td>4.1379ms</td></tr>
<tr><td>$2^{12}$</td><td>245.48ms</td><td>4.1467ms</td></tr>
<tr><td>$2^{13}$</td><td>440.64ms</td><td>4.1770ms</td></tr>
<tr><td>$2^{14}$</td><td>869.66ms</td><td>4.1870ms</td></tr>
<tr><td>$2^{15}$</td><td>1.7712s</td><td>4.3390ms</td></tr>
<tr><td>$2^{16}$</td><td>3.4499s</td><td>4.5020ms</td></tr>
<tr><td>$2^{17}$</td><td>6.7577s</td><td>5.1572ms</td></tr>
<tr><td>$2^{18}$</td><td>13.704s</td><td>6.8124ms</td></tr>
</tbody></table>
<p>The ark-plonk benchmarks are outperforming those of dusk-plonk library. For example, in dusk-plonk the results are taken with Intel(R) Core(TM) i9-9900X for a circuit of size $2^{16}$ are:</p>
<ul>
<li>Prover time: $5.46s$ which is higher than $3.44s$ in the case of ark-plonk </li>
<li>Verifier time: $9.34ms$ which is higher than $4.50ms$ in the case of Plonk.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
