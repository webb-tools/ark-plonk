<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 2: PLONK - ARK-PLONK Book</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Chapter 1: Background Material</a></li><li class="chapter-item expanded "><a href="chapter_2.html" class="active"><strong aria-hidden="true">2.</strong> Chapter 2: PLONK</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Chapter 3: ARK-PLONK library</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ARK-PLONK Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="plonk"><a class="header" href="#plonk">PLONK</a></h1>
<p>PLONK stands for Permutations over Lagrange-bases for Oecumenical Non Interactive Arguments of Knowledge.</p>
<p>PLONK is a general-purpose zero-knowledge proof scheme which solves a huge issue inherited in traditional zksnarks proof systems like Groth16: the one-time trusted setup.
The trusted setup is a preprocessing phase which creates a Structured Reference String (SRS) that is available to both prover and verifier. The reason why SRS is created is to prevent the prover from cheating and creating fake proofs and thus fulfilling the soundness property. The problem with one-time trusted setup is that it’s a one-time event which means every circuit needs a new SRS to be generated which results in slow verification time.  PLONK solves this problem by creating a single SRS that’s used for an unlimited number of arbitrary circuits (of a certain maximum size). This string is also updatable which improves security.</p>
<h2 id="plonk-components"><a class="header" href="#plonk-components">PLONK components</a></h2>
<p>PLONK can be constructed as follow:</p>
<p>Program (code)→ Arithmetic circuit → Constraint systems → Permutation checks → Polynomial commitments (A batched version of KZG10)</p>
<p>We will use the following example to be able to explain each step and the transition from one to the other. For a more detailed explanation, please check the <a href="https://eprint.iacr.org/2019/953.pdf">original PLONK paper</a> as it contains formal definitions and some interesting insights regarding efficiency etc.</p>
<p><strong>Problem definition:</strong></p>
<p>Prover wants to prove to Verifier that she knows the solution to the equation:
$$x^3+x+5=0$$</p>
<p>The goal is for Prover to evaluate the above function without revealing anything about the secret value x (solution to the equation). </p>
<p>Prover creates a program to represent the problem in a function code which then will be translated into an arithmetic circuit.</p>
<h3 id="arithmetic-circuit"><a class="header" href="#arithmetic-circuit">Arithmetic circuit</a></h3>
<p>This step transforms a program into an arithmetic circuit where two basic components: are being used: wires and gates. Plonk uses fan-in two gates, therefore each gate has a left input, a right input and an output. A circuit with n gates will have $3n$ wires. </p>
<p>PlonK is gate-based instead of R1CS-based like some proof systems like Groth16. The difference between both systems is in how they handle addition gates, in R1CS addition gates are cheap as  wires that are going from an addition to multiplication gate are not labeled which is not the case for a gate-based system. The reason why PLONK uses a gate-based instead of a R1CS fan-in;  and  thus  our  linear constraints  are  just  wiring  constraints  that  can  be reduced to a permutation check. To understand more the advantages and disadvantages of each of those designs check this <a href="https://hackmd.io/@aztec-network/plonk-arithmetiization-air#How-does-all-this-relate-to-R1CS">article</a>.</p>
<p>The following circuit translates the previous equation $x^3+x+5=0$ where we have 2 multiplication gates and 2 addition gates. </p>
<p align="center">
  <img  alt="circuit" width="250"src="images/images/circuit.png" />
</p>
<h3 id="constraint-system"><a class="header" href="#constraint-system">Constraint system</a></h3>
<p>The circuit is converted into a system of equations where the variables are the values on all the wires and there is one equation per gate. Let’s take our previous example:</p>
<p>$\begin{equation*}
\begin{dcases}
\begin{align}
a_1<em>b_1-c_1 &amp;=0 &amp; \
a_2</em>b_2-c_2 &amp;=0 &amp;\
a_3+b_3-c_3&amp;=0 &amp;\
a_4+b_4-c_4&amp;=0 
\end{align}
\end{dcases}
\end{equation*}$</p>
<p>The final result is  $x^3+x+5-c_4=0$ which represents the program we wanted to solve for $c_4=x^3+x+5=0$.
The setup for each of those equations is of the form:
$$(Q_{L_i})a_i + (Q_{R_i})b_i +(Q_{O_i})c_i + (Q_{M_i})a_ib_i  + Q_{C_{i}} =0$$</p>
<p>for  $L$= left, $R$ = right, $O$= output, $M$= multiplication, $C$= constant
The arithmetic gates are modeled with the selector vectors:  $(Q_L,Q_R,Q_O,Q_C,Q_M)$</p>
<p>Each $Q$ value is a constant. We define $Q$ for an additive gate and a multiplicative one and a constant gate as follow:<br />
For an addition gate, we set:
$$Q_{L_i}=1, Q_{R_i}=1,Q_{M_i}=0,Q_{O_i}=-1,Q_{C_i}=0$$
For a multiplication gate, we set:
$$Q_{L_i}=0, Q_{R_i}=0,Q_{M_i}=1,Q_{O_i}=-1,Q_{C_i}=0$$</p>
<p>For a constant gate setting $a_i$ to some constant $x$, we set:
$$Q_{L_i}=1, Q_{R_i}=0,Q_{M_i}=0,Q_{O_i}=0,Q_{C_i}=-x$$</p>
<p>There are two types of constraints:</p>
<ol>
<li>
<p><strong>Gate constraints:</strong> Which represents the equations between the wires attached to the same gate. For example the equation $(1)$:  $$a_1*b_1-c_1=0 $$</p>
</li>
<li>
<p><strong>Copy constraints:</strong>  PLONK enforces copy constraints which associate wires that are equal from the whole circuit so that the output of one circuit is indeed the input of the next one. These constraints are checked with a permutation argument. For example, $c_1$ the output of equation $(1)$ is also an input for another gate, we copy that constraint into a new one $a_2$ and we claim equality $c_1=a_2$</p>
</li>
</ol>
<h3 id="permutation-checks"><a class="header" href="#permutation-checks">Permutation checks</a></h3>
<p>We introduce a permutation argument  used to assure the correct execution of the circuit. It allows to check the connection between different wires inside of the circuit and make sure that the output of a certain circuit is equal to the input of another for example $(c_2=b_3)$  where $c_2$ is the output of circuit $2$ and $b_3$ is the right input of circuit $3$.</p>
<p>Let $\phi_1,..........,\phi_k \in F_{&lt;d}[X]$ and $\sigma :[kn]\rightarrow [kn] $ for $k$ = number of wires. We say for a set of polynomials $(g_1,.......,g_k) \in (F_{&lt;d}[X])^k$ that $$(g_1,g_2,........,g_k)=\sigma(\phi_1,...........,\phi_k)$$ if the following holds:</p>
<p>$g_{(l)}=\phi_{(\sigma(l))}$  for $l \in [kn]$  where $\phi_{((j-1).n+i)}=\phi_j(w^i), g_{((j-1).n+i)}=g_j(w^i)$</p>
<p>for each $j\in [k], i\in [n]$</p>
<p>The prover will be able to select an appropriate $\sigma$ for a set of wire connections and the
verifier will be convinced that the connections are correct by checking the permutation argument on the set of polynomials with itself:</p>
<p>$$
(\phi_1,\dots,\phi_k) = \sigma((\phi_1,\dots,\phi_k))
$$</p>
<p>Note that if this equality holds, we can substitute $(\phi_1,\dots,\phi_k)$ in the right hand side indefinitely as so:</p>
<p>$$
(\phi_1,\dots, \phi_k)=\
\sigma((\phi_1,\dots, \phi_k)) =\
\sigma( \sigma((\phi_1, \dots, \phi_k)) ) = \dots
$$</p>
<p>and therefore the check effectively assures that</p>
<p>$$
(\phi_1, \dots, \phi_k) = \sigma^i((\phi_1, \dots, \phi_3))
$$
for all $i \in \mathbb{N}$.</p>
<h3 id="kzg10-batched-commitments"><a class="header" href="#kzg10-batched-commitments">KZG10 Batched commitments:</a></h3>
<p>PLONK uses a batched kate commitment form in order to improve verifier efficiency by allowing for a parallel opening of commitments for each evaluation point possible. 
Let’s take $t$ polynomials of degree $\leq d;$. Let $F$ be a field of prime order. We denote by $F_{&lt;d}[X]$ the set of polynomials over $F$ of degree $&lt;d$. Let $G_1,G_2,G_t$ be groups of size $r$ and $e:G_1\times G_2\rightarrow G_t$ a bilinear pairing such that $e(g_1,g_2)=g_t$ with $g_1,g_2$ generators of $G_1$ and $G_2$ respectively.</p>
<h5 id="definition"><a class="header" href="#definition">Definition:</a></h5>
<p>d-polynomial commitment scheme is a setting of $t$ polynomials $\phi_1,\phi_2,.......,\phi_t\in F_{&lt;d}[x]$ of degree $d$ each such that $z_1,z_2,..........,z_t\in F$ are evaluation points for those polynomials. The alleged commitments to polynomials are $cm_1,cm_2,......,cm_t$ where $cm_i=com(\phi_i,srs)$ for $i\in[t]$ and alleged correct openings $s_1,s_2,.........,s_t$.</p>
<p>The commitment scheme has three steps as follow:</p>
<ul>
<li>$gen(d)$: this step will generate a structured reference string $(srs)$ in a randomized way. The algorithm chooses randomly $x\in F$ and outputs</li>
</ul>
<p>$$srs=([1]_1,[x]_1,[x^2]_1,[x^3]_1,.............[x^{d-1}]_1,[1]_2,[x]_2)$$
where   $[x]_1 =x.g_1$  and   $x_2=x.g_2$ </p>
<ul>
<li>
<p>$com(,srs)$: the commitment is computed as follow
$$com(,srs):=[\phi(x)]_1$$ </p>
</li>
<li>
<p>$open:$ we take in consideration two scenarios:</p>
<ol>
<li>
<p>All evaluation points are equal $z_1=z_2=........=z_t=z$ $$open({cm_i},{z_i},{s_i})$$ for $i \in [t]$</p>
<p>a. Verifier sends a random $\gamma\in F$</p>
<p>b. Prover computes $$h(x)=\sum_{i=1}^{t}\gamma^{i-1}.\dfrac{\phi_i(x)-\phi_i(z)}{x-z}$$ and then uses $srs$ to compute the commitment $W$ and send it to verifier $$W=h[(x)]_1$$</p>
</li>
</ol>
<p>c.  Verifier computes the following:
$$F=\sum_{i\in[t]}\gamma^{i-1}.cm_i ;and;      v=[\sum_{i\in[t]}\gamma^{i-1}.s_i]_1$$
and accepts iff $$e(F-v,[1]_2).e(-W,[x-z]_2)=1$$</p>
</li>
</ul>
<ol start="2">
<li>Let $z,z'$ be two distinct evaluation points and $t_1,t_2$ be the number of polynomials
We will describe the protocol when there are two distinct points among $z_1,\dots, z_t$. Let $z, z'$
be the distinct evaluation points and $t_1,t_2$ then number of polynomials ${f_i}<em>{i\in [t_1]},
{f_i'}</em>{i\in [t_2]}$ evaluated in $z, z'$ respectively.</li>
</ol>
<p>Note that these protocols are not zero-knowledge. The notion of zero-knowledge is not even well defined for polynomial commitments. At the end, when we present the full protocol we
will add blinders to add the zero-knowledge property to the Plonk protocol.</p>
<ol start="3">
<li>$open( {cm_i}<em>{i \in [t_1]},{cm_i'}</em>{i \in [t_2]}, z, z', {s_i}<em>{i \in [t_1]} {s_i'}</em>{i \in [t_2]})$
<ol>
<li>Verifier sends random challenges $\gamma, \gamma' \in \mathbb{F}$</li>
<li>Prover computes polynomials
$$
h(X) := \sum_{i=1}^{t_1} \gamma^{i-1} \frac{f_i(X) - f_i(z)}{X-z}\
h'(X):= \sum_{i=1}^{t_2} \gamma'^{i-1} \frac{f'_i(X) - f'_i(z')}{X-z'}
$$
and sends commitments $W=[h(x)]_1, W'=[h'(x)]_1$.</li>
<li>Verifier chooses random $r' \in \mathbb{F}$ and computes
$$
F:= \left( \sum_{i=1}^{t_1} \gamma^{i-1} \cdot cm_i -
\left[ \sum_{i=1}^{t_1} \gamma^{i-1} s_i \right]<em>1\right) +\
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot cm'<em>i -
\left[ \sum</em>{i=1}^{t_2} \gamma'^{i-1} s'_i \right]_1\right)
$$</li>
<li>Verifier accepts iff
$$
e(F +z \cdot W + r'z'\cdot W', [1]_2) =
e(W + r'\cdot W', [x]_2)
$$</li>
</ol>
</li>
</ol>
<p>Extending the right side of the check we get
$$
e(F +z \cdot W + r'z'\cdot W', [1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot cm_i -
\left[ \sum_{i=1}^{t_1} \gamma^{i-1} s_i \right]<em>1\right) +
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot cm'<em>i -
\left[ \sum</em>{i=1}^{t_2} \gamma'^{i-1} s'_i \right]<em>1\right)\ +
z \cdot \sum</em>{i=1}^{t_1} \gamma^{i-1} \frac{[f_i(x) - f_i(z)]<em>1}{x-z} +\
r'z' \cdot \sum</em>{i=1}^{t_2} \gamma'^{i-1} \frac{[f'_i(x) - f'_i(z')]_1}{x-z'}, [1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot [f_i(x)]<em>1 -
\left[ \sum</em>{i=1}^{t_1} \gamma^{i-1} f_i(z) \right]<em>1\right) +
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot [f'_i(x)]<em>1 -
\left[ \sum</em>{i=1}^{t_2} \gamma'^{i-1} f'_i(z) \right]<em>1\right)\ +
z \cdot \sum</em>{i=1}^{t_1} \gamma^{i-1} \frac{[f_i(x) - f_i(z)]<em>1}{x-z} +\
r'z' \cdot \sum</em>{i=1}^{t_2} \gamma'^{i-1} \frac{[f'_i(x) - f'_i(z')]_1}{x-z'}, [1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot
[f_i(x) - f_i(z)]<em>1 \right) +
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot
[f'_i(x) - f'_i(z)]<em>1 \right)\ +
z \cdot \sum</em>{i=1}^{t_1} \gamma^{i-1}
\frac{[f_i(x) - f_i(z)]<em>1}{x-z} +\
r'z' \cdot \sum</em>{i=1}^{t_2} \gamma'^{i-1}
\frac{[f'_i(x) - f'_i(z')]_1}{x-z'}, [1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot
[f_i(x) - f_i(z)]<em>1 \right) (1 + \frac{z}{x-z}) +\
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot
[f'_i(x) - f'_i(z)]_1 \right) (1 + \frac{z'}{x-z'}),
[1]<em>2) =\
e(  \left( \sum</em>{i=1}^{t_1} \gamma^{i-1} \cdot
[f_i(x) - f_i(z)]<em>1 \right) (\frac{x}{x-z}) +\
r' \cdot \left( \sum</em>{i=1}^{t_2} \gamma'^{i-1} \cdot
[f'_i(x) - f'_i(z)]_1 \right) (\frac{x}{x-z'}),
[1]_2)
$$</p>
<p>From the left side we get
$$
e(W + r' \cdot W', [x]<em>2) =\
e( \sum</em>{i=1}^{t_1} \gamma^{i-1}
\frac{[f_i(x) - f_i(z)]<em>1}{x-z}\ +
r' \cdot \sum</em>{i=1}^{t_1} \gamma'^{i-1}
\frac{f'_i(x) - f'_i(z')}{x-z'} , [x]_2)
$$</p>
<h2 id="plonk-protocol"><a class="header" href="#plonk-protocol">PLONK protocol</a></h2>
<p><strong>Common preprocessed input:</strong></p>
<p>The prover only uses the $\mathbb{G}_1$ part of the srs,
therefore the $\mathbb{G}_2$ part is part of the verifier
preprocessed input</p>
<p>$$
n,\
srs \rightarrow ([x]<em>1, [x^2]<em>1,\dots,[x^{n+2}]<em>1),\ 
(q_M, q_L, q_R, q_O, q_C)</em>{i=1}^n \rightarrow
\begin{cases}
q_M(X) = \sum</em>{i=1}^n q</em>{Mi} L_i(X)\
q_L(X)= \sum_{i=1}^n q_{Li} L_i(X),\
q_R(X)= \sum_{i=1}^n q_{Ri} L_i(X),\
q_O(X)= \sum_{i=1}^n q_{Oi} L_i(X),\
q_C(X)= \sum_{i=1}^n q_{Ci} L_i(X),
\end{cases}\
\sigma(X) \rightarrow
\begin{cases}
S_{\sigma_1}(X) = \sum_{i=1}^n \sigma(i) L_i(X),\
S_{\sigma_2}(X) = \sum_{i=1}^n \sigma(n+i) L_i(X),\
S_{\sigma_3}(X) = \sum_{i=1}^n \sigma(2n+i) L_i(X),\
\end{cases}\
$$</p>
<p>The public input values will be written as part of the set of wires.
Having $l$ wires as public inputs: $$l, (w_i)_{i \in [l]}$$</p>
<h3 id="prover-algorithm"><a class="header" href="#prover-algorithm">Prover Algorithm</a></h3>
<p>The prover input is the set of values assigned to each wire:</p>
<p><strong>Prover input:</strong> $(w_i)_{i \in [3n]}$</p>
<p><strong>Round 1</strong> -- Commit to wire values.</p>
<p>Generate random blinding scalars $(b_1,\dots,b_9) \in \mathbb{F}<em>p$
Compute wire polynomials
$$
a(X) = (b_1 X + b_2)Z_H(X) + \sum</em>{i=1}^n w_i L_i(X)\
b(X) = (b_3 X + b_4)Z_H(X) + \sum_{i=1}^n w_{n+i} L_i(X)\
c(X) = (b_5 X + b_6)Z_H(X) + \sum_{i=1}^n w_{2n+i} L_i(X)
$$</p>
<p>Compute commitments:
$$
[a]_1 := [a(x)]_1,
[b]_1 := [b(x)]_1,
[c]_1 := [c(x)]_1
$$</p>
<p>Output $([a]_1, [b]_1, [c]_1).$</p>
<p><strong>Round 2</strong> -- Permutation polynomial</p>
<p>Compute challenges $\beta, \gamma \in \mathbb{F}_p$:
$$
\beta = hash(Transcript,0),\
\gamma = hash(Transcript,1)
$$</p>
<p>Compute permutation polynomial $z(X)$:
$$
z(X) = (b_7  X^2 +b_8  X +b_9 )Z_H(X) +\
L_1(X) +
\sum_{i=1}^n \left(
L_{i+1}(X) \prod_{j=1}^i
\frac{  (\omega_j +\beta\omega^{j-1}+\gamma)
(\omega_{n+j} + \beta k_1 \omega^{j-1} +\gamma)
(\omega_{2n+j}+ \beta k_2 \omega^{j-1} +\gamma)}
{  (\omega_j +\beta \sigma(j) +\gamma)
(\omega_{n+j} + \beta \sigma(n+j) +\gamma)
(\omega_{2n+j}+ \beta \sigma(2n+j) +\gamma)}
\right)
$$</p>
<p>Compute $[z]_1 := [z(x)]_1$</p>
<p>Output $[z]_1$</p>
<p><strong>Round 3</strong></p>
<p>Compute quotient challenge $\alpha \in \mathbb{F}_p$
$$
\alpha = hash(Transcript)
$$</p>
<p>Compute quotient polynomial $t(X)$:
$$
t(X) :=\
\frac{1}{Z_H(X)} (a(X)b(X)q_M(X) +
a(X)q_L(X) +
b(X)q_R(X) +
c(X)q_O(X) +
PI(X) +
q_C(X)) +\
\frac{\alpha}{Z_H(X)} ((a(X) + \beta X + \gamma)
(b(X) + \beta k_1 X + \gamma)
(c(X) + \beta k_2 X + \gamma)
z(X)) -\
\frac{\alpha}{Z_H(X)} ((a(X) + \beta S_{\sigma_1}(X) + \gamma)
(b(X) + \beta S_{\sigma_2}(X) + \gamma)
(c(X) + \beta S_{\sigma_3}(X) + \gamma)
z(X \omega)) +\
(z(X) - 1)L_1(X)\frac{\alpha^2}{z_H(X)}
$$</p>
<p>Note that all terms of the polynomial are divided by $Z_H(X)$. This can be done because if all the constraints hold the then the polynomials are 0 in all elements of H, and therefore, divisible by $Z_H(X)$</p>
<p>Split $t(X)$ into $&lt;n$ degree polynomials
$t_{lo}(X), t_{mid}(X), t_{hi}(X)$ so that:</p>
<p>$$
t(X) = t_{lo}(X) + X^n t_{mid}(X) + X^{2n} t_{hi}(X) +
$$</p>
<p>Compute $[t_{lo}]<em>1 := [t</em>{lo}(x)]<em>1$,
$[t</em>{mid}]<em>1 := [t</em>{mid}(x)]<em>1$,
$[t</em>{hi}]<em>1 = [t</em>{hi}(x)]_1$</p>
<p>Output $([t_{lo}]<em>1, [t</em>{mid}]<em>1, [t</em>{hi}]_1)$</p>
<p><strong>Round 4</strong></p>
<p>Compute evaluation challenge $\zeta \in \mathbb{F}_p$:
$$
\zeta = hash(Transcript)
$$</p>
<p>Compute opening evaluations at $\zeta$:
$$
\bar{a}:= a(\zeta),
\bar{b}:= b(\zeta),
\bar{c}:= c(\zeta),\
\bar{s}<em>{\sigma_1} := S</em>{\sigma_1}(\zeta),
\bar{s}<em>{\sigma_2} := S</em>{\sigma_2}(\zeta),\
\bar{t} := t(\zeta),
\bar{z}_{\omega} := z(\omega\zeta),
$$</p>
<p>Compute linearisation polynomial $r(X)$:
$$
r(X) = 
(
\bar{a}\bar{b} \cdot q_M(X) +
\bar{a} \cdot q_L(X) +
\bar{b} \cdot q_R(X) +
\bar{c} \cdot q_O(X) +
q_C(X)
) + \
(
(\bar{a} + \beta \zeta + \gamma)
(\bar{b} + \beta k_1 \zeta + \gamma)
(\bar{c} + \beta k_2 \zeta + \gamma)
) \cdot z(X) \alpha - \
(
(\bar{a} + \beta \bar{s}<em>{\sigma_1} + \gamma)
(\bar{b} + \beta \bar{s}</em>{\sigma_2} + \gamma)
\beta\bar{z}<em>\omega \cdot S</em>{\sigma_3}(X)
)\alpha + \
z(X)L_1(\zeta)\alpha^2
$$</p>
<p>Compute linearisation evaluation at $\zeta$:
$$
\bar r:= r(\zeta)
$$</p>
<p>Output ($\bar{a}, \bar{b},\bar{c},
\bar{s}<em>{\sigma_1}, \bar{s}</em>{\sigma_2},
\bar{z}_\omega, \bar{t}, \bar{r}$)</p>
<p><strong>Round 5</strong></p>
<p>Compute opening challenge $v \in \mathbb{F}_p$:
$$
v = hash(Transcript)
$$</p>
<p>Compute opening proof polynomial $W_\zeta(X)$:</p>
<p>$$
W_\zeta(X)=
\frac{1}{X - \zeta}
\left(
(
t_{lo}(X) +
\zeta^n t_{mid}(\zeta) +
\zeta^{2n} t_{hi}(\zeta)-
\bar{t}
) +\
v(r(X) - \bar r) +\
v^2(a(X) - \bar a) +\
v^3(b(X) - \bar b) +\
v^4(c(X) - \bar c) +\
v^5(S_{\sigma_1} - \bar s_{\sigma_1}) +\
v^6(S_{\sigma_2} - \bar s_{\sigma_2}) 
\right)
$$</p>
<p>Compute opening proof polynomial</p>
<p>$$
W_{\zeta \omega}(X) = 
\frac{(z(X) - \bar z_\omega)}{X - \zeta\omega}
$$</p>
<p>Compute $[W_\zeta]<em>1:=[W</em>\zeta(x)],
[W_{\zeta \omega}]<em>1:=[W</em>{\zeta \omega}(x)]$</p>
<p>Return 
$$
\pi_{SNARK} = 
([a]_1, [b]<em>1, [c]<em>1, [z]<em>1,
[t</em>{lo}]<em>1, [t</em>{mid}]<em>1, [t</em>{hi}]<em>1,
[W</em>\zeta]<em>1, [W</em>{\zeta \omega}]<em>1, \
\bar{a}, \bar{b}, \bar{c},
\bar s</em>{\sigma_1}, \bar s</em>{\sigma_2},
\bar{r}, \bar z</em>\omega
)
$$</p>
<p>Compute multipoint evaluation challenge $u \in \mathbb{F}_p$:
$$
u := hash(Transcript)
$$</p>
<h3 id="verifier-algorithm"><a class="header" href="#verifier-algorithm">Verifier Algorithm</a></h3>
<p><strong>Verifier preprocessed input:</strong></p>
<p>$$[q_M]_1 := [q_M(x)]<em>1,[q_L]<em>1 := [q_L(x)<em>1,[q_R]<em>1 := [q_R(x)]<em>1,$$
$$[q_O]<em>1 := [q_O(x)]<em>1,[q_C]<em>1 := [q_C(x)]<em>1,[s</em>{\sigma</em>{1}}]<em>1 := [S</em>{\sigma</em>{1}}(x)],$$
$$[s</em>{\sigma</em>{2}}]<em>1 := [S</em>{\sigma</em>{2}}(x)],[s</em>{\sigma</em>{3}}]<em>1 := [S</em>{\sigma</em>{3}}(x)],([1]_2, [x]_2)$$</p>
<p><strong>Verifier input:</strong> $(w_i)<em>{[l]}, \pi</em>{SNARK}$</p>
<ol>
<li>
<p>Validate $([a]_1, [b]_1, [c]_1, [z]<em>1,
[t</em>{lo}]<em>1, [t</em>{mid}]<em>1, [t</em>{hi}]_1,
[W_z]<em>1, [W</em>{z \omega}]_1 ) \in \mathbb{G}_1$</p>
</li>
<li>
<p>Validate $(\bar a, \bar b, \bar c,
\bar s_{\sigma_1}, \bar s_{\sigma_2},
\bar z, \bar z_\omega) \in \mathbb{F}_p^7$</p>
</li>
<li>
<p>Validate $(w_i)({i \in [l]}) \in \mathbb{F}_p^l$</p>
</li>
<li>
<p>Compute challenges from common input public input and the elements of $\pi_{SNARK}$: $\beta, \gamma, \alpha, \zeta, v, u \in \mathbb{F}_p$</p>
</li>
<li>
<p>Compute $Z_H(\zeta) = \zeta^n -1$</p>
</li>
<li>
<p>Compute $L_1(\zeta) = \frac{\omega (\zeta^n - 1)}{n (\zeta - \omega)}$</p>
</li>
<li>
<p>Compute Public input polynomial evaluation
$PI(\zeta) = \sum_{i\in[l]} w_i L_i(\zeta)$</p>
</li>
<li>
<p>Compute quotient polynomial evaluation
$$
\bar t = 
\frac{
\bar r +
PI(\zeta) -
(
(\bar a + \beta \bar s_{\sigma_1} + \gamma)
(\bar b + \beta \bar s_{\sigma_2} + \gamma)
(\bar c + \gamma) \bar z_\omega
) \alpha -
L_1(\zeta) \alpha^2
}{
Z_H(\zeta)
}
$$</p>
</li>
<li>
<p>First part of batched polynomial commitment
$[D]_1 := v \cdot [r]_1 + u\cdot [z]_1$:
$$ v (\bar a \bar b [q_M]_1 +\bar a [q_L]_1 +\bar b [q_R]_1 +\bar c [q_O]<em>1 +[q_C]<em>1 )+$$
$$[z]<em>1 ((\bar a + \beta \zeta + \gamma)(\bar b + \beta k_1 \zeta + \gamma)(\bar c +<br />
\beta k_2 \zeta + \gamma)\alpha v + L_1(\zeta)\alpha^2 v +u)$$
$$ - (\bar a + \beta \bar s{\sigma_1} \zeta + \gamma)(\bar b + \beta \bar s</em>{\sigma_2} \zeta + \gamma)\alpha v\beta \bar z</em>\omega[s</em>{\sigma_3}]_1$$ </p>
</li>
<li>
<p>Compute the fully batched polynomial commitment $[F]_1$:
$$
[F]<em>1 :=
[t</em>{lo}]<em>1 +
\zeta^n [t</em>{mid}]<em>1 +
\zeta^{2n} [t</em>{hi}]_1  + 
[D]_1 +
v^2 \cdot [a]_1 +
v^3 \cdot [b]_1 +
v^4 \cdot [c]<em>1 +
v^5 \cdot [s</em>{\sigma_1}]<em>1 +
v^6 \cdot [s</em>{\sigma_2}]_1
$$</p>
</li>
<li>
<p>Compute group-encoded bath evaluation $[E]<em>1$:
$$
[E]<em>1 := 
\left[
\bar t +
v \bar r +
v^2 \bar a +
v^3 \bar b +
v^4 \bar c +
v^5 \bar s</em>{\sigma_1} +
v^6 \bar s</em>{\sigma_2} +
u \bar z_\omega
\right]_1
$$</p>
</li>
<li>
<p>Batch validate all evaluations 
$$
e(
[W_\zeta]<em>1) +
u \cdot [W</em>{\zeta \omega}]_1),
[x]<em>2
)
\stackrel{?}{=}
e(
\zeta \cdot [W</em>\zeta]<em>1) +
u \zeta \omega \cdot [W</em>{\zeta \omega}]_1) +
[F]_1 - [E]_1,
[1]_2
)
$$</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="chapter_3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="chapter_3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
